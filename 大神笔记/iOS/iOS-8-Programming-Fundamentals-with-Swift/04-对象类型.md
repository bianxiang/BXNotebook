[toc]

# 4. 对象类型

Swift 有三种对象类型：枚举、结构和类。

## 4.1 对象类型的生命和功能

对象类型的名字应该大写首字母。

```swift
class Manny {
}
struct Moe {
}
enum Jack {
}
```

对象类型的声明可以出现在任何地方：在文件顶部，在另一个对象类型声明的顶部，在函数正文内。可见性（作用域）和可使用性取决于声明的位置：

- 在文件顶部声明的对象类型，默认对工程（模块）中所有文件可见。
- 在其他对象类型内声明，给类型一个命名空间。
- 在函数正文中声明的对象类型，只在大括号范围内存在。

对象类型的声明中可以包含：

- **初始化器**。一个特殊的函数。
- **属性**。在对象类型声明顶部声明的变量是属性。默认是实例属性。也可以是 static/class 属性：对于枚举和结构，用关键字 `static` 声明；对于类，用关键字 `class` 声明。
- **方法**。在对象类型声明顶部声明的函数是方法。默认是实例方法。在实例方法中，`self` 是实例。函数也可以是 static/class 方法：对于枚举和结构，用关键字 `static` 声明；对于类，用关键字 `class` 声明；在 static/class 方法中，`self` 是类型。
- **Subscripts**。subscript 是一个特殊的实例方法。It is called by appending square brackets to an instance reference.
- 对象类型声明。对象类型声明可以嵌套。

### 4.1.1 初始化器

例子。

```swift
class Dog { }
let fido = Dog()
```

`Dog()` 会调用初始化器，但实际上我们还没有声明任何初始化器。原因是对象可以有隐式的初始化器。

初始化器是一种函数。声明时用关键字 `init`，后跟参数列表，然后是大括号包围的代码。一个对象类型可以有多个初始化器，不同初始化器之间的差别是参数列表。参数名默认是外部化的（除非你在参数名前加下划线抑制）。例子：

```swift
class Dog {
    var name = ""
    var license = 0
    init(name: String) {
    	self.name = name
    }
    init(license: Int) {
    	self.license = license
    }
    init(name: String, license: Int) {
        self.name = name
        self.license = license
    }
}
```

注意上面的初始化器中，参数名与属性名相同。通过 `self` 区分。

通过各种方式创建 `Dog` 实例：

```swift
let fido = Dog(name:"Fido")
let rover = Dog(license:1234)
let spot = Dog(name:"Spot", license:1357)
```

此时，你不再能通过无参数的初始化器创建 Dog 实例了，因为隐式的初始化器已不存在了。除非我们显式加上：

```swift
class Dog {
   init() {
   }
   ...
}
```

并不需要声明这么多初始化器。初始化器也是函数，函数可以有默认值。因此：

```swift
class Dog {
    var name = ""
    var license = 0
    init(name:String = "", license:Int = 0) {
        self.name = name
        self.license = license
    }
}
```

现在我们仍可以用四种方式创建：

```swift
let fido = Dog(name: "Fido")
let rover = Dog(license: 1234)
let spot = Dog(name:"Spot", license:1357)
let puff = Dog()
```

声明属性时可以不初始化，在初始化器中初始化。实例创建好后，但有属性还没有被初始化是违法的。即或者通过声明时初始化，或者通过初始化器，或二者都做。

在初始化器里甚至可以初始化常量属性：

```swift
class Dog {
    let name : String
    let license : Int
    init(name:String = "", license:Int = 0) {
        self.name = name
        self.license = license
    }
}
```

#### Optional 属性

有时，在初始化时并不没有合适的值给属性，或者要花很长时间才能确定值。但属性又必须全部被初始化，否则通不过编译。

一个常见的解决方式是将属性声明为 Optional 类型。nil 表示当前尚没有值；且 Optional var 会被自动初始化为 nil。

```swift
// this property will be set automatically when the nib loads
@IBOutlet var myButton: UIButton!
// this property will be set after time-consuming gathering of data
var albums : [MPMediaItemCollection]!
```

#### 引用 self

除了设置实例属性，初始化器不能引用 `self`，不论显式隐式{{不能访问实例方法或属性}}；直到所有属性被初始化。例如下面代码是违法的：

```swift
struct Cat {
    var name : String
    var license : Int
    init(name:String, license:Int) {
    	self.name = name
    	meow() // too soon - compile error
    	self.license = license
    }
    func meow() {
    	println("meow")
    }
}
```

只要把 `meow` 方法调用向下移动一行就可以了！

#### 代理初始化器

初始化器可以调用其他初始化器：`self.init(...)`。这是唯一可以显式调用初始化器的场景。

使用代理的初始化器不能引用 self，设置属性也不行，直到调用其他初始化器。录入：

```swift
struct Digit {
    var number : Int
    var meaningOfLife : Bool
    init(number:Int) {
        self.number = number
        self.meaningOfLife = false
    }
    init() {
        self.init(number: 42)
        self.meaningOfLife = true
    }
}
```

使用代理的初始化器不能设置不可变属性（let）。因为在它调用其他初始化器之前不能引用任何属性，调用后实例已经初始化好了，初始化不可变属性的大门已关闭。比如上面的代码，若 `meaningOfLife` 是 let，则代码非法。

#### 可失败的初始化器

初始化器可以声明为可失败的。此时初始化器返回一个 Optional，包裹新创建的实例。返回 nil 表示初始化失败。可失败的初始器的声明，在 `init` 后跟问号；或对于隐式解包的 Optional，后跟叹号。若要返回 nil，显式调用 `return nil`。

例子，检查参数，有问题返回 nil：

```swift
class Dog {
    let name : String
    let license : Int
    init!(name:String, license:Int) {
        self.name = name
        self.license = license
        if name.isEmpty {
        	return nil
        }
        if license <= 0 {
        	return nil
        }
    }
}
```

因为是隐式解包的，调用者可以直接把实例化的结果当做 Dog 实例。但注意检查是否为 nil。否则，

```swift
let fido = Dog(name:"", license:0)
let name = fido.name // crash
```

Cocoa 和 Objective-C 习惯上返回 nil 表示初始化失败。the API for such initializers has been hand-tweaked as a Swift failable initializer if initialization really might fail. For example, the `UIImage` initializer `init?(named:)` is a failable initializer, because there might be no image with the given name. 它不是隐式解包的，因此结果是一个 `UIImage?`，必须先解包再使用。(Most Objective-C initializers, however, are not bridged as failable initializers, even though in theory any Objective-C initializer might return nil.)

### 4.1.2 属性

属性可以是常量或变量，可以是存储的或计算的，可以有 setter observers，可以是延迟的。

存储的实例属性必须给初始值。可以在声明时或在初始化器里。属性初始化不会触发 setter observers。

初始化属性不能引用其他实例属性，或调用实例方法。例如：

```swift
class Moi {
	let first = "Matt"
	let last = "Neuburg"
	let whole = self.first + " " + self.last // compile error
}
```

解决方法之一是让属性称为计算属性：

```swift
class Moi {
	let first = "Matt"
	let last = "Neuburg"
	var whole : String {
		return self.first + " " + self.last
	}
}
```

另一种方式是声明为延迟的：

```swift
class Moi {
    let first = "Matt"
    let last = "Neuburg"
    lazy var whole : String = self.first + " " + self.last
}
```

属性的初始化不能调用实例方法：

```swift
class Moi {
    let first = "Matt"
    let last = "Neuburg"
    var whole : String = self.wholeName() // compile error
    func wholeName() -> String {
    	return self.first + " " + self.last
    }
}
```

但计算属性可以：

```swift
class Moi {
    let first = "Matt"
    let last = "Neuburg"
    var whole : String {
    	return self.wholeName()
    }
    func wholeName() -> String {
    	return self.first + " " + self.last
    }
}
```

延迟属性也可以：

```swift
class Moi {
    let first = "Matt"
    let last = "Neuburg"
    lazy var whole : String = self.wholeName()
    func wholeName() -> String {
    	return self.first + " " + self.last
    }
}
```

第3章讲过，若使用定义并调用的匿名函数，变量的初始化器可以包含多行代码。对于属性，若代码中引用了 `self`，变量必须声明为延迟的；

```swift
class Moi {
    let first = "Matt"
    let last = "Neuburg"
    lazy var whole : String = {
    	var s = self.first
    	s.extend(" ")
    	s.extend(self.last)
    	return s
    }()
}
```

static/class 属性，通过类型访问：

```swift
struct Greeting {
    static let friendly = "hello there"
    static let hostile = "go away"
}
```

其他代码可以访问 `Greeting.friendly`、 `Greeting.hostile`。这种方式我们实现了特定命名空间下的常量。

与实例属性不同的是，静态属性可以引用其他属性初始化自己；原因是静态属性的初始化是延迟的（见第3章）：

```swift
struct Greeting {
    static let friendly = "hello there"
    static let hostile = "go away"
    static let ambivalent = friendly + " but " + hostile
}
```

`friendly + " but " + hostile` 中不能用 self。可以用类型名作前缀：

```swift
struct Greeting {
    static let friendly = "hello there"
    static let hostile = "go away"
    static let ambivalent = Greeting.friendly + " but " + Greeting.hostile
}
```

如果 `ambivalent` 是一个计算属性，可以用 self：

```swift
struct Greeting {
    static let friendly = "hello there"
    static let hostile = "go away"
    static var ambivalent : String {
    	return self.friendly + " but " + self.hostile
    }
}
```

仅使用匿名函数，不能在函数中使用 self：

```swift
struct Greeting {
    static let friendly = "hello there"
    static let hostile = "go away"
    static var ambivalent : String = {
    	return self.friendly + " but " + self.hostile // compile error
    }()
}
```

### 4.1.3 方法

```swift
class Dog {
    let name : String
    let license : Int
    let whatDogsSay = "Woof"
    init(name: String, license: Int) {
        self.name = name
        self.license = license
    }
    func bark() {
    	println(self.whatDogsSay)
    }
    func speak() {
        self.bark()
        println("I'm \(self.name)")
    }
}
```

使用：

```swift
let fido = Dog(name: "Fido", license: 1234)
fido.speak() // Woof I'm Fido
```

外部化方法参数名的默认规则是特殊的：默认，第一个参数不会外部化，其他参数会被外部化。

```swift
class Dog {
	func say(s:String, times:Int) {
		for _ in 1...times {
			println(s)
		}
    }
}
```

方法名是 `say(times:)`，调用：

```swift
let d = Dog()
d.say("woof", times: 3)
```

静态方法：

```swift
struct Greeting {
    static let friendly = "hello there"
    static let hostile = "go away"
    static var ambivalent : String {
    	return self.friendly + " but " + self.hostile
    }
    static func beFriendly() {
    	println(self.friendly)
    }
}
```

调用静态方法：`Greeting.beFriendly()`

在实例方法中可以调用静态属性：

```swift
class Dog {
    static var whatDogsSay = "Woof"
    func bark() {
	    println(Dog.whatDogsSay)
    }
}
```

---

实例方法实际是 static/class 方法，是一个 curried 函数，由两个函数组成：一个函数取实例做参数，另一个取实例方法的参数列表。例如：

```
class MyClass {
    var s = ""
    func store(s:String) {
	    self.s = s
    }
}
let m = MyClass()
let f = MyClass.store(m) // what just happened!?
f("howdy")
println(m.s) // howdy
```

---

### 4.1.4 下标（Subscripts）

下标是特殊的实例方法，调用时用方括号。方括号是传给下标方法的参数。一般用于通过特定键或下标访问对象中的元素。字符串、字典或数组都可以使用这种调用方式，因为它们都有这类下标方法。

例子，返回整数特定位置上的数字：

```swift
struct Digit {
    var number : Int
    init(_ n:Int) {
    	self.number = n
    }
    subscript(ix:Int) -> Int {
        get {
            let s = String(self.number)
            return String(Array(s)[ix]).toInt()!
        }
    }
}
```

`subscript` 后跟参数列表；参数名默认不外化。箭头后面，是返回值类型（对于 getter 而言），或传入值的类型（对于 setter 而言）。

大括号内是 get 开头的读取方法和 set 开头的写入方法。若仅有读取方法没有写方法，关键字 get 和它的大括号可以省略。写入方法通过变量 `newValue` 接受新值；若想修改这个变量的名字，可以在 set 后提供一个参数名。

调用 getter 方法的示例：

```swift
var d = Digit(1234)
let aDigit = d[1] // 2
```

增加 setter：

```swift
struct Digit {
    var number : Int
    init(_ n:Int) {
    	self.number = n
    }
    subscript(ix:Int) -> Int {
        get {
        	let s = String(self.number)
        	return String(Array(s)[ix]).toInt()!
        }
        set {
        	var arr = Array(String(self.number))
        	arr[ix] = Character(String(newValue))
        	self.number = String(arr).toInt()!
        }
    }
}
```

调用 setter 的例子：

```swift
var d = Digit(1234)
d[0] = 2 // now d.number is 2234
```

对象类型可以声明多个下标方法，只要它们的签名不同。

### 4.1.5 命名空间下的对象类型

对象类型可以声明在另一个对象类型内：

```swift
class Dog {
    struct Noise {
    	static var noise = "Woof"
    }
    func bark() {
    	println(Dog.Noise.noise)
    }
}
```

内部的对象类型与其他对象类型没有什么区别。只是从外部引用的方式变了，外面的对象类型起到了命名空间的作用：

```swift
Dog.Noise.noise = "Arf"
```

## 4.2 枚举

声明的例子：

```swift
enum ListType {
    case Albums
    case Playlists
    case Podcasts
    case Books
}
```

For example, here’s how to make an instance of ListType representing the Albums case:

```swift
let type = ListType.Albums
```

若能确知类型，可以省略，但 `.` 还是要有：

```swift
let type : ListType = .Albums

func listTypeExpecter(type:ListType) {}
listTypeExpecter(.Albums)
```

实际代码中，省下的字母还是不少的，因为 Cocoa 中类型名往往很长：

```swift
let v = UIView()
v.autoresizingMask = .None
```

> 在枚举声明中使用case名可以不加点。枚举时一个命名空间，因此其中的代码可以直接看到其中的名字。

取值为相同 case 的枚举实例相等。也可以将实例与特定 case 比较。

```swift
func listTypeExpecter(type:ListType) {
	if type == .Albums {
		println("it's albums")
	}
}
listTypeExpecter(.Albums) // "it's albums"
```

### 4.2.1 Case With Fixed Value

声明枚举时，可以添加一个类型声明。所有 cases 都会带一个此类型的值（且不会变，即常量）。若类型是整数，则会自动赋值，从0开始。

```swift
enum ListType : Int {
    case Albums
    case Playlists
    case Podcasts
    case Books
}
```

`.Albums` 的值是0，`.Playlists` 的值是1。

若类型不是整数，则必须显式赋值：

```swift
enum ListType : String {
    case Albums = "Albums"
    case Playlists = "Playlists"
    case Podcasts = "Podcasts"
    case Books = "Audiobooks"
}
```

这种方式下类型只能是数值或字符串。且值必须是字面量。cases附带的值称为它们的 raw values，可以通过 `rawValue` 属性获取。

```swift
let type = ListType.Albums
println(type.rawValue) // Albums
```

raw value 必须在枚举中唯一，否则通不过编译。因为唯一，可以从 raw value 反推 case，利用 `rawValue:` 初始化器：

```swift
let type = ListType(rawValue: "Albums")
```

它是一个可失败的初始化器，即返回一个 Optional。这里，`type` 不是 `ListType`；是包裹 ListType 的 Optional。一般拿到一个枚举主要是用来比较的，又由于 Optional 的特性，比较不需要解包，因此可以直接：

```swift
let type = ListType(rawValue:"Albums")
if type == .Albums { // ...
```

其他情况下，可能需要先解包。

### 4.2.2 Case With Typed Value

另一种方式，case 的常量值在创建枚举实例时设置。
此时，声明枚举时向 case 添加一个元组类型。这类元组中一般只有一个类型，可以使用任何类型。例子：

```swift
enum Error {
    case Number(Int)
    case Message(String)
    case Fatal
}
```

使用的例子：

```swift
let err : Error = .Number(4)
```

The attached value here is called an **associated value**. 可以传入字面量，也可以传入变量。

元组可以包含几个值，带名字或不带名字。（带名字的在调用时也必须指明）：

```swift
enum Error {
    case Number(Int)
    case Message(String)
    case Fatal(n: Int, s: String)
}
let err : Error = .Fatal(n:-12, s:"Oh the horror")
```

从枚举实例中抽出 associated value 需要用到 switch 语句：

```swift
switch err {
case .Number(let theNumber):
	println("number: \(theNumber)")
case .Message(let theMessage):
	println("message: \(theMessage)")
case .Fatal(let theNumber, let theMessage):
	println("number: \(theNumber), message: \(theMessage)")
}
```

现在终于可以解释 Optional 的工作原理了。**Optional 只不过是带两个 case 的枚举**：`.None` 和 `.Some`。If it is `.None`, it carries no associated value, and it equates to `nil`. If it is `.Some`, it carries the wrapped value as its associated value. Thus, we can unwrap an Optional using exactly the same switch syntax:

```swift
let s : String? = "howdy"
switch s {
case .Some(let theString):
	println(theString) // howdy
case .None:
	println("it's nil")
}
```

### 4.2.3 枚举的初始化器

一个显式的枚举初始化器也必须完成内建初始化器做的：必须“返回”一个case。返回的意思是，将某个case赋给 `self`。例如，改造 `ListType`，让它可以被一个数字实例化：

```swift
enum ListType : String {
    case Albums = "Albums"
    case Playlists = "Playlists"
    case Podcasts = "Podcasts"
    case Books = "Audiobooks"
    static var cases : [ListType] = [Albums, Playlists, Podcasts, Books]
    init(_ ix:Int) {
    	self = ListType.cases[ix]
    }
}
```

现在我们有三种获得 ListType 实例的方式：

```swift
let type1 = ListType.Albums
let type2 = ListType(rawValue:"Playlists")!
let type3 = ListType(2) // .Podcasts
```

对于第三种情况，若用户传入的值超出合理范围怎办？为避免该问题，可以把初始化器改为 failable 初始化器，失败返回 nil。

```swift
enum ListType : String {
    case Albums = "Albums"
    case Playlists = "Playlists"
    case Podcasts = "Podcasts"
    case Books = "Audiobooks"
    static var cases : [ListType] = [Albums, Playlists, Podcasts, Books]
    init!(_ ix: Int) {
        if !(0...3).contains(ix) {
        	return nil
    	}
        self = ListType.cases[ix]
    }
}
```

枚举可以有多个初始器。枚举的初始器也可以代理给其他初始器（`self.init(...)`）。The only requirement is that, at some point in the calling chain, `self` must be set to a case.

例子，增加一个初始化器，可以通过一个 raw value（字符串）初始化，但不必出现外部参数名 `rawValue:`。为此，声明一个可失败的初始化器，并让它调用内建的 `rawValue:` 初始化器。

```swift
enum ListType : String {
    case Albums = "Albums"
    case Playlists = "Playlists"
    case Podcasts = "Podcasts"
    case Books = "Audiobooks"
    static var cases : [ListType] = [Albums, Playlists, Podcasts, Books]
    init!(_ ix:Int) {
        if !(0...3).contains(ix) {
        	return nil
        }
        self = ListType.cases[ix]
    }
    init!(_ rawValue:String) {
    	self.init(rawValue:rawValue)
    }
}
```

现在有四种方式可以实例化 ListType：

```swift
let type1 = ListType.Albums
let type2 = ListType(rawValue:"Playlists")
let type3 = ListType(2) // .Podcasts
let type4 = ListType("Playlists")
```

### 4.2.4 枚举属性

枚举可以有属性，但有限制：枚举的实例属性不能是存储属性。这是有道理的：如果同一个case的两个实例的某个存储属性的值不同，它们不相等；这与枚举的语义是相悖的。

但可以有计算属性。例如，通过一个描述属性，方便日志记录当前是哪个case。

```swift
enum ListType : String {
    case Albums = "Albums"
    case Playlists = "Playlists"
    case Podcasts = "Podcasts"
    case Books = "Audiobooks"
    var description : String { return self.rawValue }
}
```

Later, I’ll show how to make `println` fetch our description property value
automatically, so that simply calling `println(type)` will log "Albums".

If an enum instance property is a computed variable with a setter, other code can assign to this property. However, that code’s reference to the enum instance must be a variable (var), not a constant (let). If you try to assign to an enum instance property through a let reference, you’ll get a compile error.

### 4.2.5 枚举方法

枚举方法没有什么特别。但如果实例方法会修改枚举**自身**，则方法必须标记为 **mutating**。例如，实例方法可以给`self`的属性赋值；甚至可以直接修改`self`，即改变该实例的case。mutating方法的调用者的变量引用必须是变量（var），不能是常量（let）。

In this example, I add an `advance` method to my `ListType` enum. The idea is that the cases are a sequence, and the sequence can cycle. By calling advance, I transform a ListType instance into an instance of the next case in the sequence:

```swift
enum ListType : String {
	case Albums = "Albums"
	case Playlists = "Playlists"
	case Podcasts = "Podcasts"
	case Books = "Audiobooks"
	static var cases : [ListType] = [Albums, Playlists, Podcasts, Books]
	mutating func advance() {
		var ix = find(ListType.cases, self)!
		ix = (ix + 1) % 4
        self = ListType.cases[ix]
    }
}
```

```swift
var type = ListType.Books
type.advance() // type is now ListType.Albums
```

(A subscript setter is always considered mutating and does not have to be specially marked.)

## 4.3 结构

结构是Swift一种对象类型。它比类缺少一些功能。

Swift提供的内建的对象类型几乎都是结构。只有三个是类类型。String是结构。Int是结构。Range是结构。Array是结构。

### 4.3.1 结构的初始化器、属性和方法

未显式声明初始化器的结构，自动获得一个隐式的初始化器：`init()`。当结构没有存储属性，或所有的存储属性都在声明时初始化了，则不需要显式的初始化器。

若显式添加了任何初始化器，将不会提供隐式的初始化器：

```swift
struct Digit {
	var number = 42
	init(number:Int) {
		self.number = number
    }
}
```

可以调用 `Digit(number:42)`，但不能再调用 `Digit()`。除非显式添加了初始化器：

```swift
struct Digit {
    var number = 42
    init() {}
    init(number:Int) {
    	self.number = number
    }
}
```

结构，有存储属性，但没有显式初始化器，自动获得一个隐式的初始器。This is called the memberwise initializer. 例如：

```swift
struct Digit {
	var number : Int
}
```

这个机构是合法的，尽管并没有满足在声明时或初始化器中初始化所有存储属性的要求。但其实结构自动获得的 memberwise 初始器，会初始化所有属性。In this case, the memberwise initializer is called `init(number:)`.

即使存储属性在声明时被赋予了默认值，memberwise 初始器仍会存在。this struct has a memberwise initializer `init(number:)` as well (in addition to its implicit init() initializer):

```swift
struct Digit {
	var number : Int = 42
}
```

但如果显式添加了初始化器，就不会再有 memberwise 初始化器。若结构有显式的初始化器，则必须满足在声明或初始器中初始化所有存储属性。

若其他代码需要设置结构实例的属性，则它们的引用必须是变量不能是常量。

结构可以有实例方法和静态方法。若实例方法修改属性，方法必须标记为 mutating；且调用者的使用的引用必须是变量，不能是常量。mutating实例方法甚至可以把实例替换成另一个：设置  `self` 为结构的另一个实例。

(A subscript setter is always considered mutating and does not have to be specially marked.)

### 4.3.2 结构作为命名空间

我经常使用结构做常量的命名空间。即里面只有静态成员。

```swift
struct Default {
    static let Size = "Size"
    static let Style = "Style"
    static let HazyStripy = "HazyStripy"
}
```

## 4.4 类

类与结构相似，但有以下区别：

- 引用类型。类是引用类型。这意味着，类的实例比枚举或结构的实例多两个特性：
  - 可修改性：A class instance is mutable in place. 及时到类实例的引用是一个常量（let），仍可以通过此引用改变实例属性。类的实例方法不需要被标记为mutating（也不能）。
  - 多个引用：When a given instance of a class is assigned to multiple variables or passed as argument to a function, you get multiple references to one and the same object.
- 继承。类可以有父类。

在 Objective-C 中，类是唯一的对象类型。一些 Swift 内建的结构类型桥接到 Objective-C 类类型，但你自定义的结构无法这样做。因此在 Swift 中声明类的主要目的是与 Objective-C 和 Cocoa 互操作。

### 4.4.1 值类型和引用类型

枚举和结构是值类型，而类是引用类型。当把一个枚举实例或结构实体赋给一个变量，或传入、传出函数时，赋值或传递的是实例的新拷贝。即赋值、传入传出函数，是指向同一个实例的引用。

两种类型的区别之一在常量引用。常量（let）不能被赋值。

若一个常量指向一个结构的实例，我们不能通过它修改属性值：

```swift
struct Digit {
	var number : Int
	init(_ n:Int) {
		self.number = n
	}
}
let d = Digit(123)
d.number = 42 // compile error: cannot assign to 'number' in 'd'
```

原因是，结构是值类型。修改值类型的属性的唯一方式，是创建一个新的结构实例，替换原来的。但这里我们无法替换，因为 `d` 是常量。

为了证明值类型修改属性需要替换实例，我们可以在指向结构的引用上设置一个 setter 观察器；修改结构的属性会触发观察器：

```swift
var d : Digit = Digit(123) {
    didSet {
	    println("d was set")
    }
}
d.number = 42 // " d was set"
```

这就是为什么结构或枚举的实例方法，若要修改实例的属性，必须将方法标记为 `mutating`。例如：

```swift
struct Digit {
	var number : Int
	init(_ n:Int) {
		self.number = n
	}
	mutating func changeNumberTo(n:Int) {
		self.number = n
	}
}
```

没有 `mutating` 关键字，代码不能编译。(A subscript setter is always a mutating method; you don’t need to, and cannot, declare a subscript with the mutating keyword.)

上面这些讨论都不适用于类的实例。类的实例时引用类型，不是值类型。类的实例的属性若要能被修改，首先，属性要被声明为 `var`；但到类实例的引用不必一定是 `var`：

```swift
class Dog {
	var name : String = "Fido"
}
let rover = Dog()
rover.name = "Rover" // fine
```

若参数是枚举或结构，则修改它们的实例的属性时，下面是不能编译的：

```swift
func digitChanger(d:Digit) {
	d.number = 42 // compile error: cannot assign to 'number' in 'd'
}
```

正确的做饭是必须加 `var` 关键字：

```swift
func digitChanger(var d:Digit) {
	d.number = 42
}
```

但对于类类型的参数，不用加 `var` 关键字：

```swift
func dogChanger(d:Dog) {
	d.name = "Rover"
}
```

对于引用类型，引用实际指向的是一个指向实例的指针。于是，多个引用可以指向相同的实例。但结构和枚举不是这样。例子，首先是枚举：

```swift
var d = Digit(123)
println(d.number) // 123
var d2 = d // assignment!
d2.number = 42
println(d.number) // 123
```

类的例子：

```swift
var fido = Dog()
println(fido.name) // Fido
var rover = fido // assignment!
rover.name = "Rover"
println(fido.name) // Rover
```

参数传递也是一样。先是枚举的例子：

```swift
func digitChanger(var d:Digit) {
	d.number = 42
}
var d = Digit(123)
println(d.number) // 123
digitChanger(d)
println(d.number) // 123
```

类的例子：

```swift
func dogChanger(d:Dog) { // no "var" needed
	d.name = "Rover"
}
var fido = Dog()
println(fido.name) // "Fido"
dogChanger(fido)
println(fido.name) // "Rover"
```

值类型在结构上不能是递归的：值类型的属性的类型不能是这个值类型本身：

```swift
struct Dog { // compile error
	var puppy : Dog?
}
```

更复杂的循环链，如 Dog 有一个 Puppy 属性，Puppy 又有一个 Dog 属性，也是不行的。但如果 Dog 是类不是结果，就没有问题。

### 4.4.2 子类和父类

一个类只能有一个直接父类。

类可以没有任何父类。

但在 Cocoa 中，只有一个基类：`NSObject`。

声明父类的例子：

```swift
class Quadruped {
    func walk () {
        println("walk walk walk")
    }
}
class Dog : Quadruped {}
class Cat : Quadruped {}
```

Now let’s prove that `Dog` has indeed inherited walk from `Quadruped`:

```swift
let fido = Dog()
fido.walk() // walk walk walk
```

子类可以覆盖（override）父类的方法。此时必须在子类方法前显式添加关键字 `override`。例如：

```swift
class Quadruped {
    func walk () {
    	println("walk walk walk")
    }
}
class Dog : Quadruped {
    func bark () {
    	println("woof")
    }
}
class NoisyDog : Dog {
    override func bark () {
    	println("woof woof woof")
    }
}
```

注意覆盖的条件不仅是相同方法名，还要具有相同的签名、相同的外部参数名。

覆盖的方法里，通过 `super` 关键字访问父类的方法。

```swift
class Dog : Quadruped {
	func bark () {
		println("woof")
	}
}
class NoisyDog : Dog {
	override func bark () {
		for _ in 1…3 {
            super.bark()
        }
    }
}
```

下标函数是一个方法。子类也可以覆盖父类定义的下标方法，只要签名相同。要调用父类的下标方法，子类可以在`super`后使用方括号，如 `super[3]`。

子类不仅继承方法，也继承属性。属性也可以被覆盖。

若要阻止类被继承，可以在其声明前加 `final` 关键字。若要阻止类的成员被覆盖，在其声明前加 `final` 关键字。

### 4.4.3 类初始化器

由于类继承的关系，类实例的初始化比结构或枚举实例的初始化更复杂。

类的初始化器可以分为以下类型：

- 没有初始化器。类若没有存储属性，或所有的存储属性都在声明时初始化了；若类没有其他显式的初始器，则将自动获得一个隐式的初始化器 `init()`。
- 指定的（Designated）初始器。类初始化器默认是一个指定的（designated）初始器。若类存在未初始化的存储属性，则必须至少有一个指定的初始器。调用初始化器后，必须保证所有的存储属性都已初始化。指定的初始器不能调用类中其他初始化器，即不能出现 `self.init(...)`。
- 便利的（Convenience）初始器。便利的初始化器使用关键字 `convenience`标记。它是一个委托初始化器，必须执行 `self.init(...)`。最终必须委托一个指定的初始化器，即无论是直接调用，还是调用其他便利初始器，最终调用链必须是指定的初始器。

例子：

```swift
class Dog {
	var name : String
	var license : Int
	init(name:String, license:Int) {
		self.name = name
		self.license = license
	}
}
let d = Dog(name:"Rover", license:42)
```

例二，

```swift
class Dog {
	var name : String
	var license : Int
    init(name:String, license:Int) {
        self.name = name
        self.license = license
    }
	convenience init(license:Int) {
		self.init(name:"Fido", license:license)
	}
	convenience init() {
		self.init(license:1)
	}
}
let d = Dog()
```

关于一个初始器能做什么以及何时能做，如本章开头所述，仍然成立。一个指定的初始化器，除了在初始化属性时，不能使用`self`，直到所有属性被初始化。一个便利的初始器，不能使用 `self`，直到它调用了一个指定的初始化器，不管直接还是间接（也不能修改一个不可变属性）。

当类有父类时的规则：

- **无初始化器**。若子类不必为自己声明初始器，也确实没有显式声明，则子类将拥有父类的初始化器（可能多个）。

- **只有便利的初始化器**。若子类不必为自己声明初始化器，它可以声明便利的初始化器，这些初始化器可以（必须）使用从父类继承来的 designated 初始器。

- **Designated 初始器**。若子类自定义了 designated 初始器，则规则完全变了：此时，子类将不会继承任何初始器。子类现在只有显式声明的初始化器。（存在例外，见后面。）此时，子类的 designated 初始器必须调用任一父类的 designated 初始器，通过 `super.init(...)`。调用 `self` 的规则也是一样的。子类的 designated 初始器必须按以下顺序工作：
  1. 必须保证所有属性被初始化。
  2. 必须调用 `super.init(...)`，且调用的初始器必须是一个 designated 初始器。
  3. 然后，初始器才能使用 `self`，调用实例方法，访问实例属性。

  子类的便利初始器仍受制于之前讨论的规则。它们必须调用 `self.init(...)`，直接或间接的调用一个 designated 初始器。In the absence of inherited initializers, the initializer that a convenience initializer calls must be explicitly present in the subclass.

- 覆盖初始器。限制：
  - 与父类便利初始器签名相同的，也必须标记为 convenience 初始器，且不能标记 override。
  - 与父类的 designated 初始器签名相同的，可以是 designated 或 convenience 初始器，且必须标记 `override`。
  之前说，如果子类有任何 designated 初始器，则父类所有初始器都不会继承。例外：如果子类覆盖了父类所有的 designated 初始器，则子类继承父类的 convenience 初始化器。

- Failable initializers。A failable class initializer cannot say return nil until after it has completed all of its own initialization duties. Thus, for example, a failable subclass designated initializer must see to it that all the subclass’s properties are initialized and must call `super.init(...)` before it can say return nil. (There is a certain delicious irony here: before it can tear the instance down, the initializer must finish building the instance up.)
  If an initializer called by a failable initializer is failable, the calling syntax does not change, and no additional test is needed — if a called failable initializer fails, the whole initialization process will fail (and will be aborted) immediately.
  A failable initializer that returns an implicitly unwrapped Optional (init!) is treated just like a normal initializer (init) for purposes of overriding and delegation. For a failable initializer that returns an ordinary Optional (`init?`), there are some additional restrictions: `init` can override `init?`, but not vice versa. `init?` can call (delegate to) `init`, but not vice versa.

例子开始。

首先，子类没有自己的显式的初始器。

```swift
class Dog {
	var name : String
	var license : Int
	init(name:String, license:Int) {
        self.name = name
        self.license = license
	}
    convenience init(license:Int) {
        self.init(name:"Fido", license:license)
    }
}
class NoisyDog : Dog {
}
// 因为继承了父类的初始器
let nd1 = NoisyDog(name:"Fido", license:1)
let nd2 = NoisyDog(license:2)
```

但不能调用 `let nd3 = NoisyDog()`，因为 `NoisyDog` 并没有隐式的初始器，目前它只能从父类继承初始器，但父类也没有隐式的 `init()` 初始器。

例二，子类只自定义了一个 convenience 初始器：

```swift
class Dog {
    var name : String
    var license : Int
    init(name:String, license:Int) {
        self.name = name
        self.license = license
    }
    convenience init(license:Int) {
	    self.init(name:"Fido", license:license)
    }
}
class NoisyDog : Dog {
    convenience init(name:String) {
    	self.init(name:name, license:1) // 注意使用的是self不是super
    }
}
```

现在有三种方式可以实例化 `NoisyDog`：

```swift
let nd1 = NoisyDog(name:"Fido", license:1)
let nd2 = NoisyDog(license:2)
let nd3 = NoisyDog(name:"Rover")
```

例3，子类声明了一个 designated 初始化器：

```swift
class Dog {
    var name : String
    var license : Int
    init(name:String, license:Int) {
        self.name = name
        self.license = license
    }
    convenience init(license:Int) {
	    self.init(name:"Fido", license:license)
    }
}
class NoisyDog : Dog {
    init(name:String) {
	    super.init(name:name, license:1)// 注意使用的是super不是self
    }
}
```

此时，实例化 `NoisyDog` 的唯一的方式是：

```swift
let nd1 = NoisyDog(name:"Rover")
```

例4，子类覆盖父类的 designated 初始化器：

```swift
class Dog {
    var name : String
    var license : Int
    init(name:String, license:Int) {
        self.name = name
        self.license = license
    }
    convenience init(license:Int) {
	    self.init(name:"Fido", license:license)
    }
}
class NoisyDog : Dog {
    override init(name:String, license:Int) {
    	super.init(name:name, license:license)
    }
}
```

`NoisyDog`覆盖了父类所有的 designated 初始化器，因此它可以继承父类的 convenience 初始器。因此此时，会有两种实例化 NoisyDog 的方法：

```swift
let nd1 = NoisyDog(name:"Rover", license:1)
let nd2 = NoisyDog(license:2)
```

#### Surprises from Cocoa

用Swift创建 Cocoa 中类的子类时有一些意外。

你的子类 `UIBarButtonItem`，声明了一个 designated 初始器：

```swift
class LabelBarButtonItem: UIBarButtonItem {
    init(text: String) {
        let label = UILabel()
        label.text = text
        super.init(customView: label)
    }
}
```

此时就可以：

```swift
let lbbi = LabelBarButtonItem(text:"Howdy")
```

上述代码可以通过编译，但在运行时会崩溃。原因是，Cocoa 的 `UIBarButtonItem` 的designated 初始器 `init(customView:)` 调用了另一个 designated 初始化器： `init()`。虽然在Swift中这是违法的，但在 Objective-C 中是可以的。因为子类 `LabelBarButtonItem` 并没有一个 `init()`，因此会出错。

解决方法是，在子类中新增一个**私有的**、 `init()` 初始化器，直接调用 `super.init()`。

#### Required initializers

类的初始器可以加关键字 `required`。则子类也必须包含它。若子类因为有自己的 designated 初始器，导致不能继承父类的，则子类必须覆盖该初始器。例子：

```swift
class Dog {
    var name : String
    required init(name:String) {
	    self.name = name
    }
}
class NoisyDog : Dog {
    var obedient = false
    init(obedient:Bool) {
	    self.obedient = obedient
    	super.init(name:"Fido")
    }
} // compile error
```

上面代码不会通过编译。我们必须覆盖父类的 required 初始化器：

```swift
class Dog {
    var name : String
    required init(name:String) {
    	self.name = name
    }
}
class NoisyDog : Dog {
    var obedient = false
    init(obedient:Bool) {
        self.obedient = obedient
        super.init(name:"Fido")
    }
    required init(name:String) {
    	super.init(name:name)
    }
}
```

注意到覆盖的 required 初始器没有标记为 `override`，而是标记为 `required`。这样初始器的特性会继续向下传递。

### 4.4.4 Class Deinitializer

A class, and only a class (not the other flavors of object type), can have a deinitializer. This is a function declared with the keyword `deinit` followed by curly braces containing the function body. 不要自己调用这个函数；it is called by the runtime when an instance of this class goes out of existence. If a class has a superclass, the subclass’s deinitializer (if any) is called before superclass’s deinitializer (if any).

The idea of a deinitializer is that you might want to perform some cleanup, or just log to the console to prove to yourself that your instance is going out of existence in good order.

I’ll take advantage of deinitializers when I discuss memory management issues in Chapter 5.

### 4.4.5 类属性和方法

子类可以覆盖继承的属性。必须标记为 `override`。此外还有以下规则：

- The subclass property cannot be stored (because that would be the very same property, not a distinctive override).
- If the superclass property is stored, the subclass’s computed variable override must have both a getter and a setter.
- 若父类属性是计算属性，则子类的计算属性必须重新实现父类有的访问器。即，如果父类属性有读写方法，则子类也必须有读写方法。若父类是只读的，则子类是否提供写方法是自由的。
- Regardless of whether the superclass property is stored or computed, provided it is writable (a stored property or a computed property with a setter), the subclass’s override can consist of adding setter observers to this property.

The overriding property’s functions may refer to — and may read from and write to — the inherited property, through the `super` keyword.

类可以有静态成员，标记为 `static`，这一点与结构或枚举一样。但还可以有类成员，标记为 `class`。静态和类成员都会被子类继承。

从开发者角度看，静态和类方法的主要区别是，静态方法不能被覆盖；`static` 相当于 `class final`。

例子：

```swift
class Dog {
	static func whatDogsSay() -> String {
		return "woof"
	}
	func bark() {
		println(Dog.whatDogsSay())
	}
}
```

静态属性与类属性的区别与方法相似；但多了一点：静态属性可以是存储属性，但类属性只能是计算属性。

```swift
class Dog {
    static var whatDogsSay = "woof"
    func bark() {
	    println(Dog.whatDogsSay)
    }
}
```

## 4.5 多态

We may summarize Swift’s polymorphism principles as follows:

- **代替（Substitution）**。任何期待类型A的地方，可以使用类型A的子类。
- **内部标示（Internal identity）**。对象类型由其本身决定，而不是如何引用对象。

To see what these principles mean in practice, imagine we have a `Dog` class, along with its subclass, `NoisyDog`:

```swift
class Dog {
}
class NoisyDog : Dog {
}
let d: Dog = NoisyDog()
```

代替规则也适用于 Optional，即适用于被 Optional 包裹的类型。例如，若希望一个包裹 `Dog` 的 Optional（`Dog?`），可以使用一个包裹 `NoisyDog` 的 Optional （`NoisyDog?`）。背后其实是泛型的问题，后面会详细解释。

多态的另一个重要影响是 `self`。它指向实例的实际类型，即使 `self` 出现在父类的方法中。例如：

```swift
class Dog {
    func bark() {
        println("woof")
    }
    func speak() {
        self.bark()
    }
}
class NoisyDog : Dog {
    override func bark() {
	    super.bark(); super.bark()
    }
}
```

What happens when we tell a NoisyDog to `speak`? Let’s try it:

```swift
let d : NoisyDog = NoisyDog()
d.speak() // woof woof
let d2 : Dog = NoisyDog()
d2.speak() // woof woof
```

## 4.6 强制类型转换（Casting）

类A的子类B有一个类A没有的方法m。此时通过类型为类A的变量a，是不能调用方法m的。必须先把变量a强制类型转换为类型B。

强转使用 `as` 关键字。Swift will not let you cast just any **old** type to any old other type，例如，不能将 String 强转为 Int；但允许你就爱那个父类强转为子类（称为 casting down）。此时必须使用关键字 `as!`。例子：

```swift
func tellToHush(d:Dog) {
	(d as! NoisyDog).beQuiet()
}
let d: NoisyDog = NoisyDog()
tellToHush(d)
```

另一个写法，显式声明一个变量：

```swift
func tellToHush(d:Dog) {
    let d2 = d as! NoisyDog
    d2.beQuiet()
    d2.beQuiet()
}
let d: NoisyDog = NoisyDog()
tellToHush(d)
```

若运行时无法进行强转，代码会崩溃。如：

```swift
func tellToHush(d:Dog) {
	(d as! NoisyDog).beQuiet() // compiles, but prepare to crash…!
}
let d: Dog = Dog()
tellToHush(d)
```

为防止这种情况，可以先检查变量类型。一种做法是利用 `is` 关键字。

```swift
func tellToHush(d:Dog) {
	if d is NoisyDog {
		let d2 = d as! NoisyDog
		d2.beQuiet()
	}
}
```

另一种做法是利用 `as?` 运算符。结果是一个 `Optional`，处理方式与其他 Optional 一样：

```swift
func tellToHush(d:Dog) {
	let noisyMaybe = d as? NoisyDog // an Optional wrapping a NoisyDog
	if noisyMaybe != nil {
		noisyMaybe!.beQuiet()
	}
}
```

上面的代码看似没有更简短些。但如果配合使用 optionally unwrapping，则：

```swift
func tellToHush(d:Dog) {
	(d as? NoisyDog)?.beQuiet()
}
```

`as?` 的结果可能是一个包裹 `NoisyDog` 的 `Optional`，或 `nil`。

记得比较运算符可以自动对 Optional 中包裹的类型操作。`as!`、`as?`、`is` 也是这样。如，若 `d` 是一个包裹 Dog 的 Optional （`d` 是 `Dog?`）变量，它指向的 Optional 实际包裹的可能是 `Dog` 也可能是 `NoisyDog`。用 `is` 可以直接判定。不需要先解包：

```swift
let d : Dog? = NoisyDog()
if d is NoisyDog { // it is!
```

`is` 对 Optional 使用，若是 nil 则测试将失败。因此 `is` 测试实际分两步，首先检查 Optional 是否为 nil，若不是，再检查被包裹的类型。

What about casting? You can’t really cast an Optional to anything. But you can use the `as!` operator with an Optional, because Swift knows what you mean; when the thing on the left side of as! is an Optional, Swift treats it as the wrapped type. Moreover, the consequence of applying the as! operator is that two things happen: Swift unwraps first, and then casts. This code works, because d is unwrapped to give us d2, which is a NoisyDog:

```swift
let d : Dog? = NoisyDog()
let d2 = d as! NoisyDog
d2.beQuiet()
```

That code, however, is not automatically safe. You shouldn’t cast like that, without testing first, unless you are very sure of your ground. If `d` were nil, you’d crash in the second line because you’re trying to unwrap a nil Optional. And if `d` were a `Dog`, not a `NoisyDog`, you’d still crash in the second line when the cast fails. That’s why there’s also an `as?` operator, which is safe — but yields an Optional:

```swift
let d : Dog? = NoisyDog()
let d2 = d as? NoisyDog
d2?.beQuiet()
```

强转的另一个使用场景是，在 Swift 和 Objective-C 之间两个**等价的**类型相互转换。例如，可以将 Swift String 强转为 Cocoa NSString；反之亦然。不仅因为二者是子类父类关系，而且，因为它们相互桥接；in a very real sense, they are the same type. `String` 强转为 `NSString`，不是 **casting down**，因此可以直接用 `as` 运算符，不需要后面加叹号。I gave an example, in Chapter 3, of a situation where you might need to do that:

```swift
let s = "hello"
let range = (s as NSString).rangeOfString("ell") // (1,3), an NSRange
```

Swift 和 Objective-C 有不少类型是这样桥接的。Often, you won’t need to cast as you cross the bridge from Swift to Objective-C, because Swift will automatically cast for you. 例如 Swift Int 和 Cocoa NSNumber 是两个不同的类型；但你可以在期望 `NSNumber` 的地方使用 `Int`，不需要强转：

```swift
let ud = NSUserDefaults.standardUserDefaults()
ud.setObject(1, forKey: "Test")
```

上面的例子中，`1` 是 Int。但 Objective-C 期望一个 NSObject 实例。Swift 在了解到这里需要 NSObject 后，发现 NSNumber 最适合表示 Int，于是帮你建立桥梁。因此最终保存在 NSUserDefaults 中的是 `NSNumber`。

反过来，如果你调用 `objectForKey:`，Swift不知道返回值是什么，因此你需要将其显式强转为 `Int`。这里是 casting down（后面会解释为什么）：

```swift
let i = ud.objectForKey("Test") as! Int
```

如果 `ud.objectForKey("Test")` 返回的不是 `NSNumber`，代码将崩溃。使用 `as?` 或先检查类型可能更安全点。

## 4.7 类型引用

实例能够获得到它的类型的引用，然后可以访问类的静态/类成员。

Objective-C中可以使用实例的 `class` 方法。但Swift中，实例不一定是类类型，也可能是结构或枚举，因此需要用 `dynamicType` 方法。

```swift
class Dog {
    class var whatDogsSay : String {
        return "Woof"
    }
    func bark() {
	    println(self.dynamicType.whatDogsSay)
    }
}
```

`dynamicType` 也是遵守多态的：

```swift
class Dog {
    class var whatDogsSay : String {
    	return "Woof"
    }
    func bark() {
        println(self.dynamicType.whatDogsSay)
    }
}
class NoisyDog : Dog {
    override class var whatDogsSay : String {
    	return "Woof woof woof"
    }
}

let nd = NoisyDog()
nd.bark() // Woof woof woof
```

When you say `println(myObject.dynamicType)`, you’ll see something legible in the console; it will be namespaced, so it will have the module name (and possibly some other information) attached to it, but the name of this object’s type will be plain to see.

有时，你需要就爱那个对象类型作为一个值传递。对象类型本身也是一个对象。

声明一个对象类型的变量或方法参数，使用类型名，后跟`.Type`：

```swift
func typeExpecter(whattype:Dog.Type) {
}
```

调用或赋值时，类型名，或类型名加 `.self` 后缀都可以作为值赋给变量。

```swift
typeExpecter(Dog) // or: typeExpecter(Dog.self)
```

或，从类型的实例出发，通过 `dynamicType`：

```swift
let d = Dog() // or: let d = NoisyDog()
typeExpecter(d.dynamicType) // or: typeExpecter(d.dynamicType.self)
```

典型应用，工厂函数：传入一个类型，创建该类型的实例：

```swift
class Dog {
    var name : String
    init(name:String) {
    	self.name = name
    }
}
class NoisyDog : Dog {
}

func dogMakerAndNamer(whattype: Dog.Type) -> Dog {
	let d = whattype(name:"Fido") // compile error
	return d
}
```

编译失败的原因是，编译器怀疑，是否 `init(name:)` 初始器被 `Dog` 所有子类实现了。为消除编译器疑虑，在初始器前加 `required` 关键字：

```swift
class Dog {
    var name : String
    required init(name:String) {
	    self.name = name
    }
}
```

调用示例：

```swift
let d = dogMakerAndNamer(Dog) // d is a Dog named Fido
let d2 = dogMakerAndNamer(NoisyDog) // d2 is a NoisyDog named Fido
```

在类方法中，`self` 表示类，且是多态的。于是在一个类方法中，可以通过 `self()` 调用初始器，且是多态的。例子：

```swift
class Dog {
    var name : String
    required init(name:String) {
	    self.name = name
    }
    class func makeAndName() -> Dog {
    	let d = self(name:"Fido")
    	return d
    }
}
class NoisyDog : Dog {
}
```

It works as expected:

```swift
let d = Dog.makeAndName() // d is a Dog named Fido
let d2 = NoisyDog.makeAndName() // d2 is a NoisyDog named Fido
```

但有一个问题。`d2` 虽然是实际是 `NoisyDog`，但变量类型却是 `Dog`。这是因为 `makeAndName` 方法返回类型是 `Dog`。为此我们乤一个多态的类型声明。这里我们可以用 `Self` （注意大写的首字母）：

```swift
class Dog {
    var name : String
    required init(name:String) {
    	self.name = name
    }
    class func makeAndName() -> Self {
    	let d = self(name:"Fido")
        return d
    }
}
class NoisyDog : Dog {
}
```

`Self` 也可以在实例方法中使用。下面我们写一个实例方法版本的工厂方法。Here, we start with a Dog or a NoisyDog and tell it to have a puppy of the same type as itself:

```swift
class Dog {
    var name : String
    required init(name:String) {
    	self.name = name
    }
    func havePuppy(#name:String) -> Self {
    	return self.dynamicType(name:name)
    }
}
class NoisyDog : Dog {
}
```

And here’s some code to test it:

```swift
let d = Dog(name:"Fido")
let d2 = d.havePuppy(name:"Fido Junior")
let nd = NoisyDog(name:"Rover")
let nd2 = nd.havePuppy(name:"Rover Junior")
```

相关概念总结：

- `.dynamicType`。In code, sent to an instance: the polymorphic (internal) type of this instance, regardless of how the instance reference is typed. Static/class members are accessible through an instance’s `dynamicType`.
- `.Type`。In declarations, sent to a type: the type (as opposed to an instance of the type). For example, in a function declaration, Dog means a Dog instance is expected, but Dog.Type means that the Dog type itself is expected.
- `.self`。In code, sent to a type: the type. For example, to pass the Dog type where Dog.Type is expected, you can pass Dog.self. (It is not illegal to send .self to an instance, but it is pointless.)
- `self`。In instance code, this instance, polymorphically. In static/class code, this type, polymorphically; self(...) instantiates this type.
- `Self`。In a method declaration, when specifying the return type, this class or this instance’s class, polymorphically.

## 4.8 协议

协议用于表达多个不非常相关类型之间的共性。如蜜蜂和鸟都能飞。

但二者不一定能通过父类-子类关系存在。一种原因是现实语义上的，鸟或蜜蜂不同种。另外，二者不一定都是类，可能是**结构**。协议就是解决这些问题的。协议在Swift中非常重要。Swift头文件定义了超过70个协议。

A protocol is an object type, but it doesn’t make any objects of its own. 不能实例化一个协议。协议声明值是一组属性和方法。属性没有值，方法没有实现。由实现协议的对象类型负责实现协议中的属性和方法。

例子。协议 `Flier` 只有一个 `fly` 方法。

```swift
protocol Flier {
	func fly()
}
```

任何类型（枚举、结构、类）或另一个协议都可以采取此协议。声明时，将协议名放在自己的名字后面，签名加冒号。若有父类，就放父类后面。父类必须要放在冒号后的最前面。例子：

```swift
protocol Flier {
	func fly()
}
struct Bird : Flier {
	func fly() {
	}
}
```

### 4.8.1 为什么要用协议？

协议也是一种。因此可以在需要类型的地方出现协议：声明变量类型，参数类型等。

```swift
func tellToFly(f:Flier) {
	f.fly()
}
```

协议也是多态的。协议创造了另一种表述类型和子类型的方法。例如上面，`Flier` 类型的参数可以接受任意对象类型的实例，不管是枚举、结构、类，只要它们遵循 `Flier` 协议。

类型可以采纳多个协议。例如内建的 `Double` 类型采纳了 Printable, Hashable, Comparable 等协议。

```swift
struct MyType : Printable, Hashable, Comparable {
// ...
}
```

### 4.8.2 协议类型的测试和强转

`is`、 `as!` 和 `as?` 都可以用于协议类型。

```swift
func tellGetWorm(f:Flier) {
	(f as? Bird)?.getWorm()
}
```

### 4.8.3 声明一个类型

协议声明只能在文件顶部。协议声明以关键字 `protocol` 开头，后跟协议名。协议声明可以包含以下内容。

**属性**
协议中，属性声明包含 var（不能是let）、属性名、冒号、类型，然后是大括号，里面包含关键字 `get` 或 `get set`。子类可以有以下选择：

- 子类可以将该属性实现为一个存储属性。
- 若协议只指定了 get，则子类可以将该属性声明为存储属性，但是常量（let）。
- 即使协议只指定了 get，子类可以让该属性称为可读写属性。

子类不能做到是，如果协议指定了 get set，不能将属性实现为只读的计算属性，或常量存储属性（let）。换言之，如果协议规定该属性是可写的，则必须是可写的。

To declare a static/class property, precede it with the keyword `static`. A class adopter is free to implement this as a **class** property.

**方法**

协议中的方法声明没有正文。大括号也没哟。任何对象函数类型都可以可以的，包括初始器和下标函数。

To declare a static/class method, precede it with the keyword `static`. A class adopter is free to implement this as a `class` method.

仅当协议中方法有标记 `mutating`时，子类为枚举或结构时，才能添加 `mutating` 关键字，否则不能。但子类可以省略，即使协议中声明了 mutating。

**类型别名**

例如 `typealias Time = Double`。

**Protocol adoption**

协议自身可以采纳一个或多个别的协议；语法是在协议名后，冒号加逗号分隔的协议名。

If the only purpose of a protocol would be to combine other protocols by adopting all of them, without adding any new requirements, and if this combination is used in just one place in your code, you can avoid formally declaring the protocol in the first place by creating the combining protocol on the fly. To do so, use a type name `protocol<..., ...>`, where the contents of the angle brackets is a comma-separated list of protocols. For example, in a function declaration, a parameter type could be specified as `protocol<Printable, DebugPrintable>`, meaning that this value must be an object type that adopts `Printable` and `DebugPrintable`.

### 4.8.4 Optional Protocol Members

Objective-C中，协议的成员可以声明为可选，表示子类可以选择不实现该成员。为兼容 Objective-C，Swift允许可选的协议成员，但只能在显式桥接到Objective-C的协议中（`@objc` 标示）使用。在这样的协议中，可选的成员（方法和属性）通过关键字 `optional`标示：

```swift
@objc protocol Flier {
	optional var song : String {get}
	optional func sing()
}
```

只有类采纳才能这种协议，且类必须为 `NSObject` 的子类，或标记为 `@objc` 的类，或可选的成员标记为`@objc`：

```swift
@objc class Bird : Flier {
    func sing() {
    	println("tweet")
    }
}
```

调用可选的成员，返回值是 Optional。若未实现，返回 nil。

> 有可能你会收到两层包装的 Optional。例如，若属性本身是Optional，如 String?，则你将得到 String??。

In the case of an optional method like sing, things are more elaborate. If the method is not implemented, we must not be permitted to call it in the first place. To handle this situation, the method **itself** is automatically typed as an Optional version of its declared type. To send the sing message to a Flier, therefore, you must unwrap it. The safe approach is to unwrap it optionally, with a question mark:

```swift
let f : Flier = Bird()
f.sing?()
```

That code compiles — and it also runs safely. The effect is to send the sing message to `f` only if this adopter implements sing. If the actual type of this adopter doesn’t implement sing, nothing happens. You could have force-unwrapped the call — `f.sing!()` — but then your app would crash if the adopter doesn’t implement sing.

If an optional method returns a value, that value is wrapped in an `Optional` as well. For example:

```swift
@objc protocol Flier {
    optional var song : String {get}
    optional func sing() -> String
}
```

If we now call `sing?()` on a Flier, the result is an Optional wrapping a String:

```swift
let f : Flier = Bird()
let s = f.sing?() // s is an Optional wrapping a String
```

If we force-unwrap the call — `sing!()` — the result is either a String (if the adopter implements sing) or a crash (if it doesn’t).

很多 Cocoa 协议都有可选的成员。如 `UIApplicationDelegate` 协议，所有方法都是可选的。

An optional property can be declared `{get set}` by its protocol, but there is no legal syntax for setting such a property in an object of that protocol type. For example, if `f` is a `Flier` and `song` is declared `{get set}`, you can’t set `f.song`. I regard this as a bug in the language.

### 4.8.5 Class Protocol

协议声明冒号后加关键字 `class` 的，表示一个类声明，表示它只能被类对象类型采纳：

```swift
protocol SecondViewControllerDelegate : class {
	func acceptData(data:AnyObject!)
}
```

Like the `@objc` attribute, 此项特性的目的是兼容 Objective-C。(In fact, the `@objc` attribute implies that this is also a class protocol.)

此系那个特性的主要目的是为了利用类特有的内存管理特性。后面会细说，现在只给一个例子：


```swift
class SecondViewController : UIViewController {
	weak var delegate : SecondViewControllerDelegate?
	// ...
}
```

The keyword `weak` marks the delegate property as having special memory management. Only a class instance can participate in this kind of special memory management. The `delegate` property is typed as a protocol, and a protocol might be adopt by a struct or an enum type. So to satisfy the compiler that this object will in fact be a class instance, and not a struct or enum instance, the protocol is declared as a class protocol.

### 4.8.6 Implicitly Required Initializers

若协议声明了一个初始器，且一个类采纳了该协议。则类及其子类都要实现该初始器。因此类不仅要实现该初始化器，还要将其标记为 required。An initializer declared in a protocol is thus implicitly required, and the class is forced to make that requirement explicit.

例如下面的代码，若初始器没有 `required` 关键字，将无法通过编译。

```swift
protocol Flier {
	init()
}
class Bird : Flier {
	required init() {}
}
```

另一种做法是将类标记为 `final`。即不让它有子类。

That fact is responsible for one of the strangest and most annoying features of real-life iOS programming with Swift. Let’s say you subclass the built-in Cocoa class `UIViewController` — something that you are extremely likely to do. And let’s say you give your subclass an initializer — something that you are also extremely likely to do:

```swift
class ViewController: UIViewController {
    override init() {
    	super.init(nibName: "ViewController", bundle: nil)
    }
}
```

That code won’t compile. The compile error says: “required initializer init(coder:) must be provided by subclass of UIViewController.” What on earth is going on? Well, it turns out that UIViewController adopts a protocol, NSCoding. And this protocol requires an initializer init(coder:). None of that is your doing; UIViewController and NSCoding are declared by Cocoa, not by you. But that doesn’t matter! This is the same situation I was just describing. In order to adopt NSCoding, UIViewController must not only implement `init(coder:)`, but also it must mark it required. Therefore, because your subclass has implemented a designated initializer of its own — thus cutting off initializer inheritance — it must also implement init(coder:) and mark it required!

But that makes no sense, especially if you are not expecting `init(coder:)` ever to be called on your `UIViewController` subclass. You are being asked to write an initializer for which you can provide no meaningful functionality. Fortunately, Xcode’s Fix-It feature will offer to write the initializer for you, like this:

```swift
required init(coder aDecoder: NSCoder) {
	fatalError("init(coder:) has not been implemented")
}
```

That code satisfies the compiler. (I’ll explain in Chapter 5 why it’s a legal initializer even though it doesn’t fulfill an initializer’s contract.) It also deliberately crashes if it is ever called. If you do have functionality for this initializer, you will delete the fatalError line and insert your own functionality in its place.

Not only `UIViewController` but lots of built-in Cocoa classes adopt NSCoding. You will encounter this problem if you subclass any of those classes and implement your own initializer. It’s just something you’ll have to get used to.

### 4.8.7 Literal Convertibles

One of the wonderful things about Swift is that so many of its features, rather than being built-in and accomplished by magic, are implemented in Swift and are exposed to view in the Swift header. Literals are a case in point. The reason you can say 5 to make an Int whose value is 5, instead of formally initializing Int by saying `Int(5)`, is not because of magic. It’s because `Int` adopts a protocol, `IntegerLiteralConvertible`. Not only Int literals, but all literals work this way. The following literal convertible protocols are declared in the Swift header:

- NilLiteralConvertible
- BooleanLiteralConvertible
- IntegerLiteralConvertible
- FloatLiteralConvertible
- StringLiteralConvertible
- ExtendedGraphemeClusterLiteralConvertible
- UnicodeScalarLiteralConvertible
- ArrayLiteralConvertible
- DictionaryLiteralConvertible

你自定义的对象类型也可以采纳一个字面量转换协议。然后在期待对象类型的地方，可以直接使用字面量。如：

```swift
struct Nest : IntegerLiteralConvertible {
    var eggCount : Int = 0
    init() {}
    init(integerLiteral val: Int) {
    	self.eggCount = val
    }
}
```

`Nest` 采纳了 `IntegerLiteralConvertible`后，在需要 `Nest` 的地方可以使用 `Int`， `init(integerLiteral:)`会被自动调用。

```swift
func reportEggs(nest:Nest) {
	println("this nest contains \(nest.eggCount) eggs")
}
reportEggs(4) // this nest contains 4 eggs
```

## 4.9 泛型

A generic is a sort of placeholder for a type, into which an actual type will be slotted later. 因为Swift的强类型，所以才需要使用泛型。

In particular, they do not postpone resolution of a type until runtime. When you use a generic, your code will still specify its real type; that real type is known with complete specificity at compile time! The particular region of your code where the type is expected uses a generic so that it doesn’t have to specify the type fully, but at the point where that code is used by other code, the type is fully resolved.

Optional是一个好例子。Optional中包裹的类型是确定的。因为 Optional 是一个泛型类型。前面讲过了，Optional是一个枚举，有两个 cases： `.None`、`.Some`。在 Swift 头中， Optional 枚举时这样的：

```swift
enum Optional<T> {
    case None
    case Some(T)
    init(_ some: T)
    // ...
}
```

```swift
let s = Optional("howdy")
```

也可以写成：

```swift
let s : Optional<String> = "howdy"
```

### 4.9.1 泛型声明

泛型可以在哪里声明：

**`Self` 与泛型协议**

在协议中，利用关键字 `Self`（注意大写）让协议变成泛型的。`Self` 表示子类的类型。This is parallel to `Self` as a return type in method declarations in classes; but in a protocol, 但不仅可用于返回值类型。例如，here’s a Flier protocol that declares a method that takes a `Self` parameter:

```swift
protocol Flier {
	func flockTogetherWith(f:Self)
}
```

若类 `Bird` 实现了 `Flier` 协议，则 `flockTogetherWith` 的实现，`f` 参数类型为 `Bird`。

**泛型协议与空的类型别名**

A protocol can declare a type alias without any assignment defining what the type alias stands for. This turns the protocol into a generic, and the alias name (also called an associated type) is a placeholder. For example:

```swift
protocol Flier {
    typealias Other
    func flockTogetherWith(f:Other)
    func mateWith(f:Other)
}
```

```swift
struct Bird : Flier {
    func flockTogetherWith(f:Bird) {}
    func mateWith(f:Bird) {}
}
```

**泛型函数**

函数声明可以使用占位符，可以用于参数、返回值类型和正文内。占位符的名字放在函数名后的尖括号内：

```swift
func takeAndReturnSameThing<T> (t:T) -> T {
    return t
}
```

下面的例子，调用时展位符的类型是推断出来的：

```swift
let thing = takeAndReturnSameThing("howdy")
```

**泛型对象类型**

占位类型名放在类型名后的尖括号内。占位类型名可以在类型声明中的任意地方使用。

```swift
struct HolderOfTwoSameThings<T> {
    var firstThing : T
    var secondThing : T
    init(thingOne:T, thingTwo:T) {
        self.firstThing = thingOne
        self.secondThing = thingTwo
    }
}
```

```swift
var holder = HolderOfTwoSameThings(thingOne:"howdy", thingTwo:"getLost")
```

泛型函数和泛型对象类型，可以使用多个占位符：

```swift
func flockTwoTogether<T, U>(f1:T, f2:U) {}
```

### 4.9.2 类型约束

之前的例子都允许任意类型取代占位符。我们也可以限制某些类型才能取到占位符，称为类型约束（constraint）。最简单的约束是，在占位符首次出现的地方，添加冒号及一个类型名；这里的类型名可以是类名或协议名。

例如，下面的协议。该协议的子类必须实现 `flockTogetherWith` 方法。且 `f` 的类型必须准确是 `Flier`。但我们实际想允许子类实现的 `flockTogetherWith` 方法，`f` 的类型只要是 `Flier` 或其子类就行。

```swift
protocol Flier {
	func flockTogetherWith(f:Flier)
}
```

因此应该这样表达：

```swift
protocol Flier {
    typealias Other : Flier
    func flockTogetherWith(f:Other)
}
```

现在子类可以：

```swift
struct Bird : Flier {
	func flockTogetherWith(f:Bird) {}
}
```

(You may be thinking that since Other is used in only one place in the protocol Flier’s declaration, we could dispense with the type alias and just have Flier declare a generic function instead. That’s not true, because that would mean something else entirely. 若协议声明了一个泛型函数，表示说子类也必须声明相同的泛型函数，更之前完全不同了。)

在泛型函数或泛型对象类型中，类型约束出现在尖括号中：

```swift
func flockTwoTogether<T:Flier>(f1:T, f2:T) {}
```

如果 Bird 和 Insect 都是 Flier 的子类，则 `flockTwoTogether` 调用时可以传两个 Bird 参数或两个 Insect 参数；但不能传一个 Bird 和 一个 Insect。

一个实际的例子。创建一个函数 `myMin`，返回列表中最小的一个。无法通过编译的写法：

```swift
func myMin<T>(things:T…) -> T {
    var minimum = things[0]
    for ix in 1..<things.count {
        if things[ix] < minimum { // compile error
    	    minimum = things[ix]
        }
    }
    return minimum
}
```

问题在于 `things[ix] < minimum`。不是所有值都能被比较。确保类型实现 `Comparable` 协议：

```swift
func myMin<T:Comparable>(things:T…) -> T { // ...
```

一个泛型协议（协议声明中有用 `Self` 或空的类型别名）只能用作泛型中的类型，即作为类型约束。下面的代码通不过编译：

```swift
protocol Flier {
    typealias Other
	func fly()
}
func flockTwoTogether(f1:Flier, f2:Flier) {
    // compile error
    f1.fly()
    f2.fly()
}
```

`Flier` 是一个泛型协议。要将其作为一个类型使用，必须让函数称为泛型函数，让 `Flier` 作为类型约束。

```swift
protocol Flier {
    typealias Other
    func fly()
}
func flockTwoTogether<T1:Flier, T2:Flier>(f1:T1, f2:T2) {
    f1.fly()
    f2.fly()
}
```

### 4.9.3 显式的特化（Specialization）

In the examples so far, the user of a generic resolves the placeholder’s type through inference. But there’s another way to perform resolution: the user can resolve the type manually. This is called explicit specialization. In some situations, explicit specialization is mandatory — namely, if the placeholder type cannot be resolved through inference.

主要由两种形式的显式的特化：

**带空类型别名的泛型协议**

The adopter of a protocol can resolve the protocol’s empty alias type manually through a typealias declaration using the protocol’s alias name with an explicit type assignment. For example:

```swift
protocol Flier {
	typealias Other
}
struct Bird : Flier {
	typealias Other = String
}
```

**泛型对象类型**

手工设定占位符类型。例子：

```swift
class Dog<T> {
	var name : T? = nil
}
let d = Dog<String>()
```

但不能显式特化一个泛型函数。You can, however, declare a generic type with a nongeneric function that uses the generic type’s placeholder; explicit specialization of the generic type resolves the placeholder, and thus resolves the function:

```swift
protocol Flier {
	init()
}
struct Bird : Flier {
	init() {}
}
struct FlierMaker<T:Flier> {
	static func makeFlier() -> T {
		return T()
	}
}
let f = FlierMaker<Bird>.makeFlier() // returns a Bird
```

When a class is generic, it is quite tricky to subclass it in a way that’s acceptable to the compiler (I regard this as a bug in Swift itself). My solution is to declare the subclass as a generic subclass of a manually resolved version of the superclass, even if the subclass’s placeholder isn’t used for anything:

```swift
class Dog<T> {
    var name : T? = nil
}
class NoisyDog<U> : Dog<String> {
}
```

To use the subclass, you have to resolve the placeholder manually, even if your resolution is pointless:

```swift
let d = NoisyDog<Int>() // the Int is pointless
d.name = "Fido"
```

### 4.9.4 Where 子句

The angle brackets of a generic function or object type declaration can contain a where clause, which can solve some knotty expressive problems by honing further the constraints on the placeholder type.

例如，如果添加多个约束？对于泛型**协议**，可以用逗号分隔的类型列表：

```swift
protocol Flier {}
protocol Walker {}
protocol FlierWalker {
	typealias T : Flier, Walker // T must adopt Flier and Walker
}
```

对于泛型函数或对象类型，解决方法是在占位符名后加where子句：

```swift
protocol Flier {}
protocol Walker {}
func flyAndWalk<T where T:Walker, T:Flier> (f:T) {}
```

Another powerful use of where clauses is to constrain further a generic protocol type used as a constraint in a generic function or object type. For example:

```swift
protocol Flier {
    typealias Other
}
func flockTogether<T:Flier where /*???*/> (f:T) {}
```

The generic protocol’s placeholder is its empty type alias (its associated type), so what you’re constraining here is that associated type. The goal, then, is to restrict what sort of thing `Other` must resolve to. The name Other exists only in the namespace of Flier, and here is to be applied to the placeholder T. So the syntax is:

```swift
protocol Flier {
    typealias Other
}
func flockTogether<T:Flier where T.Other /*???*/ > (f:T) {}
```

(If Other were itself constrained to a generic protocol type, the dot-notation could be extended to its type alias. I’ll show an example in a moment.)

The missing part of the where clause may be one of the following:

- A colon and a protocol type. The resolved type alias is constrained to be an adopter of this protocol.
- An equality operator and an object type. The resolved type alias is constrained to be of this type.
- An equality operator and another placeholder-plus-type-alias. The resolved type aliases are constrained to be the same type as one another.

Here’s a (silly) example where the type alias is constrained to a protocol:

```swift
protocol Flier {
    typealias Other
}
struct Bird : Flier {
    typealias Other = String
}
struct Insect : Flier {
    typealias Other = Bird
}
func flockTogether<T:Flier where T.Other:Equatable> (f:T) {}
```

In that example, the function flockTogether can be called with a Bird parameter, because a Bird’s Other type alias is resolved to String, and String adopts the built-in Equatable protocol — but the function flockTogether can’t be called with an Insect parameter, because an Insect’s Other type alias is resolved to Bird, and Bird doesn’t adopt the Equatable protocol.

The Swift header makes extensive use of where clauses of this kind. For example, here’s the declaration of the built-in find function:

```swift
func find<C : CollectionType where C.Generator.Element : Equatable> (domain: C, value: C.Generator.Element) -> C.Index?
```

The Find function returns the index number of a requested object within a given collection; I gave some examples in Chapter 3, such as `find("howdy", "o")`. Observe the chaining of the type alias names in C.Generator.Element. A `CollectionType` is something like a String or an Array; it has an empty type alias Generator, which is constrained to be a GeneratorType, which in turn has an empty type alias Element. That’s fancy talk for a simple concept — it means, “The kind of thing this is a collection of.” The where clause then says that the kind of thing the placeholder C is a collection of must be an Equatable — very sensibly, because there is no way to find an object in a collection if there is no way to know whether two objects are equal! You can’t find a needle in a haystack unless you have a way of identifying a needle when you see it.

Based on that model, we can write a where clause specifying that we want a collection of some specific element type, such as Character; this is an object type, not a protocol, so we use == and not a colon:

```swift
func printc<C : CollectionType where C.Generator.Element == Character>(c:C) {
    for char in c {
        println(char)
    }
}
```

Either of these two calls to printc is legal, because a String is a collection of Character and an array of Character is a collection of Character:

```swift
printc("howdy")
printc(["h" as Character, "i" as Character])
```

Finally, here’s an example (again silly) of a where clause constraining two type aliases to be the same type as one another:

```swift
protocol Flier {
    typealias Other
}
struct Bird : Flier {
    typealias Other = String
}
struct Insect : Flier {
    typealias Other = Int
}
func flockTwoTogether<T:Flier, U:Flier where T.Other == U.Other> (f1:T, f2:U) {}
```

In that code, the function flockTwoTogether can be called with a Bird and a Bird, and it can be called with an Insect and an Insect, but it can’t be called with an Insect and a Bird because their Other type aliases are not resolved to the same type. Interestingly, the type of a generic protocol’s resolved type alias can also be referred to outside a where clause. I’ll give an example later in this chapter.)

## 4.10 Extensions

An extension is a way of injecting your own code into an object type that has already been declared elsewhere. This could be one of your own object types; in that case, you could have put this functionality into the original object type declaration, and the extension is merely a device to allow you to organize your code more clearly and conveniently. However, it could be one of Swift’s object types or one of Cocoa’s Objective-C object types; in that case, you are adding functionality to a type that doesn’t belong to you!

To declare an extension, put the keyword `extension` followed by the name of an existing object type, then optionally a colon plus the names of any protocols you want to add to the list of those adopted by this type, and finally curly braces containing the usual things that go inside an object type declaration — with the following restrictions:

- An extension can’t redefine (override) an existing member.
- An extension can’t declare a stored property (but it can declare a computed property).
- An extension of a class can’t declare a designated initializer or a deinitializer (but it can declare a convenience initializer).

In my real programming life, I sometimes extend a built-in Swift or Cocoa type just to encapsulate some missing functionality by expressing it as a property or method. Here are a couple of examples from actual apps.

如，扩展 Swift 内建的 `Array` 类型，给它一个 `shuffle` 方法：

```swift
extension Array {
	mutating func shuffle () {
        for i in stride(from:self.count-1, to:0, by:-1) {
            let ix1 = i
            let ix2 = Int(arc4random_uniform(UInt32(i+1)))
            (self[ix1], self[ix2]) = (self[ix2], self[ix1])
        }
    }
}
```

Cocoa的Core Graphics框架的 CGRect 结构，增加一个获取中心点（`CGPoint`）的方式，增加一个计算属性：

```swift
extension CGRect {
	var center : CGPoint {
		return CGPointMake(self.midX, self.midY)
	}
}
```

An extension can declare a static or class method; since an object type is usually globally available, this can often be an excellent way to slot a global function into an appropriate namespace. For example, in one of my apps, I find myself frequently using a certain color (a `UIColor`). Instead of creating that color repeatedly, it makes sense to encapsulate the instructions for generating it in a global function. But instead of making that function completely global, I make it — appropriately enough — a **class** method of `UIColor`:

```swift
extension UIColor {
	class func myGolden() -> UIColor {
		return self(red:1.000, green:0.894, blue:0.541, alpha:0.900)
	}
}
```

Now I can use that color throughout my code simply by saying `UIColor.myGolden()`, completely parallel to built-in class methods such as `UIColor.redColor()`.

A frequent use of extensions is to make an object type adopt a protocol. Of course, you then also have to implement the members required by that protocol, if they are not implemented already. For example, the Core Graphics `CGAffineTransform` struct isn’t logged nicely in the
console with `println`; it isn’t a `Printable`. It’s easy to make it a `Printable`, though, because there’s a Cocoa function for representing a `CGAffineTransform` as a string:

```swift
extension CGAffineTransform : Printable {
	public var description : String {
		return NSStringFromCGAffineTransform(self)
	}
}
```

As I mentioned earlier, extensions on one’s own object types can help to organize one’s code. A frequently used convention is to add an extension for each protocol one’s object type needs to adopt, like this:

```swift
class ViewController: UIViewController {
	// ... UIViewController method overrides go here…
}
extension ViewController : UIPopoverPresentationControllerDelegate {
	// ... UIPopoverPresentationControllerDelegate methods go here…
}
extension ViewController : UIToolbarDelegate {
	// ... UIToolbarDelegate methods go here…
}
```

An extension on your own object type is also a good way to spread your definition of that object type over multiple files, if you feel that several shorter files are better than one long file.

When you extend a generic object type, you cannot add new placeholders to this object type, and you cannot add new constraints to its existing placeholder types. However, the existing placeholder type names are in scope inside your extension declaration. That’s good, because you might need to use them; but it makes your code a little mystifying, because you seem to be using some undefined type names out of the blue. It might be a good idea to add a comment, to remind yourself what you’re up to. Here’s an artificial example (and I’ll give a real example later in this chapter):

```swift
class Dog<T> {
	var name : T? = nil
}
extension Dog {
	func sayYourName() -> T? { // T is the type of self.name
        return self.name
    }
}
```

When you extend a Swift struct, a curious thing happens with initializers: it becomes possible to declare an initializer and keep the implicit initializers:

```swift
struct Digit {
	var number : Int
}
extension Digit {
    init() {
	    self.init(number:42)
    }
}
```

That code means that you can instantiate a `Digit` by calling the explicitly declared initializer — `Digit()` — or by calling the implicit memberwise initializer — `Digit(number:7)`. Thus, the explicit declaration of an initializer through an extension did not cause us to lose the implicit memberwise initializer, as would have happened if we had declared the same initializer inside the original struct declaration.


