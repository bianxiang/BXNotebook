[toc]

# 2 线程安全编写线程安全代码的关键是管理对状态的访问，特别是对共享的、可变状态的访问。对象的状态即其字段或静态字段。对象的状态也包含其他依赖对象的状态，如 HashMap 的状态存放在 HashMap 自己中，也在多个 Map.Entry 对象中。对象的状态包含任何可能影响其可见的行为的数据。对象是否需要是线程安全的，取决于它是否会被多个线程访问 —— 这是对象如何被使用的问题，而不是对象做什么的问题。当多个线程访问某个状态，且其中一个是写操作，则所有这些访问都需要使用同步协作。Java中主要的同步机制是 `synchronized` 关键字，但术语 **synchronization** 也包含 volatile 变量、显式锁、原子变量。三种解决未同步访问可变状态问题的办法：
1.	不要跨线程共享状态变量2.	令状态变量不可变3.	所有访问时使用同步开始就让类是线程安全的比后面修改要容易的多。在大型程序中，识别是否有多个线程访问给定变量是困难的。一些面向对象技术技术可以帮助提高代码可维护性，如封装和数据隐藏。访问特定变量的代码｛｛路径｝｝越少，保证合适同步越简单。Java语言本身不强制封装（可以使用 public 字段），可以发布内部对象的引用。
封装、不可变对象、声明不变式。有时不得不因性能等原因破坏向对象原则。但记住，并发bug太难调，不顾风险提高性能是否值得。第4章会讲什么时候放松对状态变量的封装是可以的。一个完全由线程安全类组成的程序不一定是线程安全的。组合线程安全类的问题也在第4章讲。不管怎样只有当类封装其状态时线程安全类才有意义。## 2.1 什么是线程安全？线程安全类封装所有需要的同步，因此调用者不需要再提供｛｛同步｝｝。例子：无状态Servlet。Listing 2.1 因子分解。Listing 2.1. A Stateless Servlet.```java@ThreadSafepublic class StatelessFactorizer implements Servlet {    public void service(ServletRequest req, ServletResponse resp) {        BigInteger i = extractFromRequest(req);        BigInteger[] factors = factor(i);        encodeIntoResponse(resp, factors);    }}```无状态的对象总是线程安全的。## 2.2 原子性
向无状态对象加个属性：计数字段。Listing 2.2. Servlet that Counts Requests without the Necessary Synchronization. Don't Do this.

```java@NotThreadSafepublic class UnsafeCountingFactorizer implements Servlet {    private long count = 0;    public long getCount() { return count; }    public void service(ServletRequest req, ServletResponse resp) {        BigInteger i = extractFromRequest(req);        BigInteger[] factors = factor(i);        ++count;        encodeIntoResponse(resp, factors);    }}```
`++` 是 read-modify-write 操作。The possibility of incorrect results in the presence of unlucky timing is so important in concurrent programming that it has a name: a race condition.### 2.2.1 Race Conditions`UnsafeCountingFactorizer` 有好几个 race conditions！A race condition occurs when the correctness of a computation depends on the relative timing or interleaving of multiple threads by the runtime; in other words, when getting the right answer relies on lucky timing. [4] 最常见的 race condition 类型是 check-then-act。[4] 术语 race condition 经常与术语 data rac e混淆。data race 指访问共享的非final字段时未使用同步。Code with data races has no useful defined semantics under the Java Memory Model. 不是所有的 race conditions 都是 data races，也不是所有的 data races 都是 race conditions。UnsafeCountingFactorizer 既有 race conditions 也有 data races。第16章讲 data races。一种叫 check-then-act 的 race condition：先观察，然后根据观察行动，但在观察和行动之间观察可能失效。

### 2.2.2 例子：延迟初始化中的 Race Conditions使用 check-then-act 的一项常见操作是延迟初始化。Listing 2.3. Race Condition in Lazy Initialization. Don't Do this.

```java@NotThreadSafepublic class LazyInitRace {    private ExpensiveObject instance = null;    public ExpensiveObject getInstance() {        if (instance == null)            instance = new ExpensiveObject();        return instance;    }}```
两个线程可能同时观察到 null 并各自初始化一个实例，最后可能得到两个不同的实例。`UnsafeCountingFactorizer` 中的计数有另外一种 race condition：read-modify-write。### 2.2.3 复合操作要保证线程安全， check-then-act 操作和 read-modify-write 操作必须是原子的。Listing 2.4. Servlet that Counts Requests Using AtomicLong.

```java@ThreadSafepublic class CountingFactorizer implements Servlet {    private final AtomicLong count = new AtomicLong(0);    public long getCount() { return count.get(); }    public void service(ServletRequest req, ServletResponse resp) {        BigInteger i = extractFromRequest(req);        BigInteger[] factors = factor(i);        count.incrementAndGet();        encodeIntoResponse(resp, factors);    }}```当状态变量从一个变多个时，仅仅用原子变量很可能不够。## 2.3 锁缓存上一次分解的数及结果，若下一个请求相同，则直接返回。使用原子变量尝试写个程序（第15章会具体讲原子变量）：Listing 2.5. Servlet that Attempts to Cache its Last Result without Adequate Atomicity. Don't Do this.```java@NotThreadSafepublic class UnsafeCachingFactorizer implements Servlet {     private final AtomicReference<BigInteger> lastNumber         = new AtomicReference<BigInteger>();     private final AtomicReference<BigInteger[]> lastFactors         = new AtomicReference<BigInteger[]>();     public void service(ServletRequest req, ServletResponse resp) {         BigInteger i = extractFromRequest(req);         if (i.equals(lastNumber.get()))             encodeIntoResponse(resp, lastFactors.get() );         else {             BigInteger[] factors = factor(i);             lastNumber.set(i);             lastFactors.set(factors);             encodeIntoResponse(resp, factors);         }     }}```上面的程序仍是线程不安全的。`UnsafeCachingFactorizer` 存在 race conditions。多个变量参与了不变式，它们不是独立的，需要在一个原子里一起更新。此外，**两个值还必须一起取**。以防取一个值时另一个值被改变。### 2.3.1 固有锁
固有锁（Intrinsic Locks）。静态同步方法使用Class对象做锁。```javasynchronized (lock) {    // Access or modify shared state guarded by lock}```
任何 Java 对象都可以做同步的锁，内建的锁称为 intrinsic locks 或 monitor locks。正常退出同步块或因抛异常退出都会释放锁。获得固有锁的唯一方法是进入同步块。Java 的固有锁是互斥锁（mutexes, or mutual exclusion locks）：一次至多有一个线程可以拥有锁。当线程A尝试获取的锁已被线程B占用，线程A等待、或block。如果B永远不释放，A永远等待。一个简单的修改，线程安全了，但性能未优化。
Listing 2.6. Servlet that Caches Last Result, But with Unnacceptably Poor Concurrency. Don't Do this.```java@ThreadSafepublic class SynchronizedFactorizer implements Servlet {    @GuardedBy("this") private BigInteger lastNumber;    @GuardedBy("this") private BigInteger[] lastFactors;    public synchronized void service(ServletRequest req,                                     ServletResponse resp) {        BigInteger i = extractFromRequest(req);        if (i.equals(lastNumber))            encodeIntoResponse(resp, lastFactors);        else {            BigInteger[] factors = factor(i);            lastNumber = i;            lastFactors = factors;            encodeIntoResponse(resp, factors);        }    }}```

### 2.3.2 可重入固有锁是可重入的，线程可以获取它已拥有的锁。Reentrancy means that locks are acquired on a per-thread rather than per-invocation basis. [7] 通过锁计数实现，当计数为0时表示没有线程拥有锁，重入时计数加1。[7] This differs from the default locking behavior for pthreads (POSIX threads) mutexes, which are granted on a per-invocation basis.若锁不是可重入的，下面的代码会导致死锁：子类覆盖父类方法并调用父类方法。Because the doSomething methods in Widget and LoggingWidget are both synchronized, each tries to acquire the lock on the Widget before proceeding. But if intrinsic locks were not reentrant, the call to super.doSomething would never be able to acquire the lock because it would be considered already held, and the thread would permanently stall waiting for a lock it can never acquire. Reentrancy saves us from deadlock in situations like this.
Listing 2.7. Code that would Deadlock if Intrinsic Locks were Not Reentrant.```javapublic class Widget {    public synchronized void doSomething() {        ...    }}public class LoggingWidget extends Widget {    public synchronized void doSomething() {        System.out.println(toString() + ": calling doSomething");        super.doSomething();    }}
```## 2.4 使用锁看管状态一个常见的错误是认为只有写操作需要被同步。（该问题的原因在3.1节中会细讲。）每个共享的、可变的变量都应被一把（且只有一把）锁监控。向维护者说明白是哪把锁。当有多个变量参与不变式时，附加要求：这些变量必须被同一把锁看管。仅把所有方法置为同步还不够，例如 vector 的所有方法都是同步的，但下面的操作仍是非原子的：

```javaif (!vector.contains(element)) vector.add(element);```
## 2.5 Liveness 与性能
CachedFactorizer 将同步拆成两个。一个用来看管 check-then-act 另一个用来看管更新两个状态变量。将对局部变量的访问排除在同步之外。｛｛下面的代码与其分解为两个同步块，不如重构出更细粒度的方法，并对方法同步 —— 一个方法中多个同步块是方法需要被拆细的信号！｝｝
Listing 2.8. Servlet that Caches its Last Request and Result.```java@ThreadSafepublic class CachedFactorizer implements Servlet {    @GuardedBy("this") private BigInteger lastNumber;    @GuardedBy("this") private BigInteger[] lastFactors;    @GuardedBy("this") private long hits;    @GuardedBy("this") private long cacheHits;    public synchronized long getHits() { return hits; }    public synchronized double getCacheHitRatio() {        return (double) cacheHits / (double) hits;    }    public void service(ServletRequest req, ServletResponse resp) {        BigInteger i = extractFromRequest(req);        BigInteger[] factors = null;        synchronized (this) {            ++hits;            if (i.equals(lastNumber)) {                ++cacheHits;                factors = lastFactors.clone();            }        }        if (factors == null) {            factors = factor(i);            synchronized (this)  {                lastNumber = i;                lastFactors = factors.clone();            }        }        encodeIntoResponse(resp, factors);    }}```也不能将同步块拆的太细，因为获取、释放锁也有开销。避免对耗时运算加锁，如网络和IO。