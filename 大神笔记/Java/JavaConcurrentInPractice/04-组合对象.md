[toc]

# 4 组合对象将线程安全组件组合成仍旧是线程安全的组件或程序。## 4.1 设计线程安全类

封装可以在不检查整个程序的情况下判定一个类是线程安全的。

线程安全类的设计需要考虑以下几个方面：

- 识别构成类状态的变量。
- 识别状态参与的不变式。
- 建立管理并发访问对象状态的策略。

对象的状态首先包括字段。如果字段都是基本类型，字段就是全部状态。**如果对象的字段是对其他对象的引用，则对象状态包括被引用对象的字段。**例如 `LinkedList` 的状态包括所有元素的状态（不只所有元素，还有元素的状态）。

指定同步策略来保证并发访问不会破坏不变式和后置条件。同步策略选择使用不可变对象、thread confinement 或锁来维护线程安全，同步策略指定变量使用何种锁看管。

Listing 4.1. Simple Thread-safe Counter Using the Java Monitor Pattern.

```java
@ThreadSafe
public final class Counter {
    @GuardedBy("this")  private long value = 0;

    public synchronized long getValue() {
        return value;
    }
    public  synchronized long increment() {
        if (value == Long.MAX_VALUE)
            throw new IllegalStateException("counter overflow");
        return ++value;
    }
}
```

### 4.1.1 收集同步需求对象有状态空间：所有可能的状态组合。状态空间越小，越容易分析。使用final字段可以减少分析。后置条件。如当前值为17，加一后18。根据当前值得到下一个值是复合运算。不变式和后置条件的约束导致需要同步和封装。If certain states are invalid, then the underlying state variables must be encapsulated, otherwise client code could put the object into an invalid state. 如果一个操作将产生无效的状态转移，则它必须是原子的。若不变式涉及多个状态，访问这些状态需要原子性。
确保安全的前提是明确不变式和后置条件。Class invariants and method postconditions constrain the valid states and state transitions for an object.### 4.1.2 依赖状态的操作
例如，队列只有非空时才可以移除元素。若方法有基于状态的前置条件（state-based preconditions），称方法为 state-dependent。[CPJ 3]在单线程程序中，若前置条件不满足，方法只能失败。但在并发程序中，前置条件可能随后被其他线程置为满足。并发程序可能要停下来等待前置条件满足，然后继续。有效的等待条件满足的内建机制 —— wait and notify —— 与固有锁紧密相关。但可能非常难以正确使用。要想创建等待条件的操作，可以使用类库，如阻塞队列和 semaphores，使用它们实现 state-dependent 行为。Blocking library classes such as `BlockingQueue`, `Semaphore`, and other synchronizers are covered in Chapter 5; creating state-dependent classes using the low-level mechanisms provided by the platform and class library is covered in Chapter 14.### 4.1.3 State OwnershipWe implied in Section 4.1 that an object's state could be a subset of the fields in the object graph rooted at that object. Why might it be a subset? Under what conditions are fields reachable from a given object not part of that object's state?When defining which variables form an object's state, we want to consider only the data that object owns. Ownership is not embodied explicitly in the language, but is instead an element of class design. If you allocate and populate a `HashMap`, you are creating multiple objects: the `HashMap` object, a number of `Map.Entry` objects used by the implementation of `HashMap`, and perhaps other internal objects as well. The logical state of a `HashMap` includes the state of all its `Map.Entry` and internal objects, even though they are implemented as separate objects.For better or worse, garbage collection lets us avoid thinking carefully about ownership. When passing an object to a method in C++, you have to think fairly carefully about whether you are transferring ownership, engaging in a short-term loan, or envisioning long-term joint ownership. In Java, all these same ownership models are possible, but the garbage collector reduces the cost of many of the common errors in reference sharing, enabling less-than-precise thinking about ownership.In many cases, ownership and encapsulation go together - the object encapsulates the state it owns and owns the state it encapsulates. 由状态的拥有者决定使用何种锁协议保护状态的完整性。拥有意味着控制，但一旦你发布了一个可变对象，你不再拥有排他性控制，充其量你拥有共享的控制。A class usually does not own the objects passed to its methods or constructors, unless the method is designed to explicitly transfer ownership of objects passed in (such as the synchronized collection wrapper factory methods).Collection classes often exhibit a form of "split ownership", in which the collection owns the state of the collection infrastructure, but client code owns the objects stored in the collection. An example is ServletContext from the servlet framework. ServletContext provides a Map-like object container service to servlets where they can register and retrieve application objects by name with `setAttribute` and `getAttribute`. `ServletContext` 必须是线程安全的，因为它一定会被多线程访问。Servlets在使用 `setAttribute` 和 `getAttribute` 时无需使用同步，但使用存储在 `ServletContext` 中的对象时必须使用同步。这些对象的所有者是应用。为了保证多线程访问安全，它们必须是线程安全的、有效不可变的或用锁看管。
`HttpSession` 有着更高的要求，Servlet 容器会访问 HttpSession 中的对象，将其序列化用于 replication or passivation。由于除了应用代码，容器也会访问它们，因此它们需要是线程安全的。(We say "may have" since replication and passivation is outside of the servlet specification but is a common feature of servlet containers.)## 4.2 Instance Confinement
如果对象不是线程安全的，仍可以通过某些技术在多线程环境中使用。如使用 thread confinement 或使用锁看管。Encapsulation simplifies making classes thread-safe by promoting instance confinement, often just called confinement [CPJ 2.3.3]. 如果一个对象被封装进另一个对象，可到被封装对象的所有代码路径均是可知的，分析它要比分析可被整个应用使用的对象简单的多。锁与 confinement 结合使用，可以确保未线程安全的对象以线程安全的方式使用。Encapsulating data within an object confines access to the data to the object's methods, making it easier to ensure that the data is always accessed with the appropriate lock held.首先对象不能泄漏。对象可以被限定到一个类实例（如私有类成员）、一个词法作用域（如局部变量）、一个线程（例如对象在一个线程中的方法之间传递）。`PersonSet` 展示了如何通过限制和锁使类变为线程安全的，即便其状态变量不是线程安全的。 `HashSet` 不是线程安全的，但由于 `mySet` 是私有的且未泄漏，因此 `HashSet` 被限定在 `PersonSet` 之中。能访问 `mySet` 的唯一代码路径是 `addPerson()` 和 `containsPerson()` 方法，每个方法都要求 `PersonSet` 的锁。因为 `PersonSet` 所有的状态都由锁看管，它是线程安全的。
Listing 4.2. Using Confinement to Ensure Thread Safety.```java@ThreadSafepublic class PersonSet {    @GuardedBy("this")    private final Set<Person> mySet = new HashSet<Person>();    public synchronized void addPerson(Person p) {        mySet.add(p);    }    public synchronized boolean containsPerson(Person p) {        return mySet.contains(p);    }}```Instance confinement 是构造线程安全类最简单的方式之一。它有一个好处是可以灵活选择锁策略。例子中`PersonSet` 使用它自己的锁包含状态。还有其他选择。Instance confinement 也允许不同的状态变量被不同的锁看管。(For an example of a class that uses multiple lock objects to guard its state, see ServerStatus on 236.)Java平台类库中有多个使用限定的例子，有些目的是将非线程安全类转换为线程安全的。基本集合如 `ArrayList` 和 `HashMap` 不是线程安全的，但类库提供包装方法（如 `Collections.synchronizedList`）。这些包装器使用了装饰器模式。The wrapper implements each method of the appropriate interface as a synchronized method that forwards the request to the underlying collection object. 只要包装器对象是唯一可访问底层集合的代码（即底层集合限定于包装器），则包装对象是线程安全的。 如果某个对象被限定于某个作用域，则发布它是bug。受限对象也可能通过外围对象发布其他对象而泄漏（这些对象持有对受限对象的引用）。限定使构造线程安全类变得简单，因为不必检查整个程序，只检查外围限定类就能分析。### 4.2.1 Java Monitor 模式Following the principle of instance confinement to its logical conclusion leads you to the Java monitor pattern.[2] 遵循 Java monitor 模式的对象封装其所有可变状态并使用对象的固有锁看管它们。[2] The Java monitor pattern is inspired by Hoare's work on monitors (Hoare, 1974), though there are significant differences between this pattern and a true monitor. 进入和退出同步块的字节码指令甚至叫 monitorenter 和 monitorexit。Java 内建锁（固有锁）有时称 monitor locks 或 monitors。Listing 4.1 就是遵循该模式的一个例子。Java monitor 模式的有点是简单，但有时需要更复杂的锁模型。除了 Java monitor 模式，其实可以使用任意锁看管状态，只要能一致的使用。如Listing 4.3。
Listing 4.3. Guarding State with a Private Lock.```javapublic class PrivateLock {    private final Object myLock = new Object();    @GuardedBy("myLock") Widget widget;    void someMethod() {        synchronized(myLock) {            // Access or modify the state of widget        }    }}```使用私有锁比使用对象的固有锁（或其他可以公开访问的锁）有几点好处。Making the lock object private encapsulates the lock so that client code cannot acquire it, whereas a publicly accessible lock allows client code to participate in its synchronization policycorrectly or incorrectly. 代码不当的获取另一个对象的锁可能导致 liveness 问题，verifying that a publicly accessible lock is properly used requires examining the entire program rather than a single class.### 4.2.2 例子：Tracking Fleet Vehicles一个复杂的使用 Java monitor 的例子：车辆调配。我们先使用 monitor 模式构建，然后看如何放松封装同时仍能保持线程安全。每辆车辆有一个辨识（String）和位置。

```javaMap<String, Point> locations = vehicles.getLocations();for (String key : locations.keySet())    renderVehicle(key, locations.get(key));void vehicleMoved(VehicleMovedEvent evt) {    Point loc = evt.getNewLocation();    vehicles.setLocation(evt.getVehicleId(), loc.x, loc.y);}```
视图线程和更新线程会并发访问数据模型，因此数据模型必须是线程安全的。Listing 4.4 的实现使用了 Java monitor 模式，使用 MutablePoint（Listing 4.5）表示位置。
Listing 4.4. Monitor-based Vehicle Tracker Implementation.```java@ThreadSafepublic class MonitorVehicleTracker {    @GuardedBy("this")    private final Map<String, MutablePoint> locations;    public MonitorVehicleTracker(            Map<String, MutablePoint> locations) {        this.locations = deepCopy(locations);    }    public synchronized Map<String, MutablePoint> getLocations() {        return deepCopy(locations);    }    public synchronized MutablePoint getLocation(String id) {        MutablePoint loc = locations.get(id);        return loc == null ? null : new MutablePoint(loc);    }    public synchronized void setLocation(String id, int x, int y) {        MutablePoint loc = locations.get(id);        if (loc == null)            throw new IllegalArgumentException("No such ID: " + id);        loc.x = x;        loc.y = y;    }    private static Map<String, MutablePoint> deepCopy(            Map<String, MutablePoint> m) {        Map<String, MutablePoint> result =                new HashMap<String, MutablePoint>();        for (String id : m.keySet())            result.put(id, new MutablePoint(m.get(id)));        return Collections.unmodifiableMap(result);    }}public class MutablePoint { /*  Listing 4.5  */ }```
Listing 4.5. Mutable Point Class Similar to Java.awt.Point.

```java@NotThreadSafepublic class MutablePoint {    public int x, y;    public MutablePoint() { x = 0; y = 0; }    public MutablePoint(MutablePoint p) {        this.x = p.x;        this.y = p.y;    }}```
尽管 `MutablePoint` 不是线程安全的，但tracker类是。map和可变的点都没有被发布。当需要向外报告一个位置时，拷贝副本，深度复制整个 Map。通过拷贝可变数据返回给客户端来保证线程安全。当集合不大时，性能问题不大。[4] Another consequence of copying the data on each call to getLocation is that the ontents of the returned collection do not change even if the underlying locations change. Whether this is good or bad depends on your requirements. It could be a benefit if there are internal consistency requirements on the location set, in which case returning a consistent snapshot is critical, or a drawback if callers require up-to-date information for each vehicle and therefore need to refresh their snapshot more often.[4] 因为深度拷贝在同步方法中进行，tracker的固有锁会在长时间运行的操作过程中保持，这可能导致UI响应过慢。｛｛如果EDT要获得锁，而该锁被长时间任务占有，EDT会阻塞！｝｝