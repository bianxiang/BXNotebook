[toc]

### 2.3. 复合（Compound）类型

复合类型是根据另一个类型定义的类型。C++中有多种复合类型，其中两种是 *引用* 和 *指针*。

声明是一个基础（base）类型，跟着一组声明符（declarators）。**一个声明符命名一个变量**，同时给这个变量一个相对于基础类型的类型。

之前看到的声明，声明符只有变量名。这类变量的类型就是基础类型。

#### 2.3.1. 引用（reference）

> 新标准引入了一种新的引用：右值引用（§13.6.1）。这种引用主要用在类内部。技术上讲，当我们提到引用时，指的都是左值引用。

引用，定义了对象的另一个名称。一个引用类型指向另一个类型。引用类型的说明符是 `&d`，其中 `d` 是变量名：

```cpp
int ival = 1024;
int &refVal = ival; // refVal指向ival，或者说是ival的另一个名字
int &refVal2; // 错误：引用必须被初始化
```

一旦初始化，引用一直绑定到初始化的对象。**无法将引用重新绑定到另一个对象**。因此引用必须初始化。

##### 引用即别名

对引用的操作实际是操作引用绑定的对象：

```cpp
refVal = 2; // 将2赋给refVal指向的对象，即ival
int ii = refVal; // same as ii = ival

int &refVal3 = refVal; // refVal3现在也指向ival了
int i = refVal; // i现在具有与ival相同的值
```

因为引用不是对象，因此不能定义到引用的引用。

##### 引用定义

在单个定义中可以定义多个引用。注意**每个**变量名前都要加 `&`：

```cpp
int i = 1024, i2 = 2048; // i and i2 are both ints
int &r = i, r2 = i2; // r是引用类型，但 r2 是 int
int &r3 = i3, &r4 = i2; // both r3 and r4 are references
```

**引用的类型与对象类型必须一致**（两个例外：§2.4.1、§15.2.3）。

```cpp
double dval = 3.14;
int &refVal5 = dval; // 错误
```

引用只能绑定到对象，不能绑定到字面量。原因在 §2.4.1 解释。

```cpp
int &refVal4 = 10; // 错误
```

#### 2.3.2. 指针

指针本身也是对象。可以改变指针指向的对象。不一定要在定义时初始化。在块级作用域上，未初始化的指针的值是未定义的。

指针类型的说明符是 `*d`，`d` 是变量名。

```cpp
int *ip1, *ip2; // both ip1 and ip2 are pointers to int
double dp, *dp2; // dp2是指针，但dp是double
```

##### 取对象地址

指针持有对象的地址。使用 `&` 获取对象地址：

```cpp
int ival = 42;
int *p = &ival; // p保存ival的地址；p是指针
```

指针与对象必须类型一致（两个例外：§2.4.2、 §15.2.3）。

##### 指针值

指针存放的值（即地址）可以有四种状态：

- 它可以指向一个对象
- 它可以指向对象位置之后的下一个位置
- 它可以是空指针，表示不绑定到任何对象
- 可能是无效值。上述三者之外都是无效值

访问无效指针的结果是不定的。尽管第2、第3种指针是有效的，但使用受限。因为这些指针不指向任何对象，因此不用于访问指向的对象。如果访问了，结果是不定的。

##### 使用指针访问对象

若指针指向一个对象，可以用 dereference 运算符(`*`)访问那个对象。

```cpp
int ival= 42;
int *p = &ival;
cout << *p;  // prints 42
```

##### 空指针

空指针不指向任何对象。代码在使用指针前要检查是否为空。有几种方式获得一个空指针：

```cpp
int *p1 = nullptr; // 等价于int *p1 = 0;
int *p2 = 0;
// must #include cstdlib
int *p3 = NULL; // 等价于int *p3 = 0;
```

`nullptr` 是新标准引入的。`nullptr` 是一个字面量，有**特殊类型**，可以被转换为任何指针类型。

老的程序一般会用预处理器变量 **NULL**，**cstdlib** 头将其定义为 `0`。**预处理器变量** 不是命名空间的一部分。因此引用它们是不用加 `std::` 等前缀。

现代C++程序尽量避免使用**NULL**，用 `nullptr` 吧。

可以给指针赋值字面量0，但不能为指针赋一个整数**变量**，即便其值是0。

```cpp
int zero = 0;
pi = zero; // 错误，不能将整数赋给指针
```

##### 赋值（Assignment）

赋值可以让指针指向不同的对象：

```cpp
int i = 42;
int *pi = 0;
int *pi2 = &i; // pi2持有i的地址
int *pi3; // 如果pi3定义在块内，其值是未定义的
pi3 = pi2; // pi3 and pi2 address the same object, e.g., i
pi2 = 0; // pi2 now addresses no object
```

##### 其他指针运算

**只要指针的值有效**，可以参与条件。0值为false，其他为true。

**相同类型**的有效指针可以使用 `==` 和 `!=` 运算符。运算符的结果是 `bool`。持有相同地址的指针相等。**两个null指针相等**。一个指针，与另一个指向另一个对象的指针地址可能相同（第二个指针执行一个对象的地址的下一个地址），此时比较是相等的。

**比较无效的指针的结果是未定的**。

更多指针操作见 §3.5.3。

##### `void*` 指针

`void*` 是一个特殊的指针类型，可以持有任何对象的地址。对象的类型是不定的。

```cpp
    double obj = 3.14, *pd = &obj;
    void *pv = &obj; // obj can be an object of any type
    pv = pd; // pv can hold a pointer to any type
```

可以与其他指针比较｛｛相同类型的？｝｝。**但不能用于操作地址上的对象** —— 我们不知道对象的类型。

#### 2.3.3. 理解复合类型声明

每个说明符定义一个变量，其类型与基础类型的关系可以不同。因此，单个定义可以定义多种不同类型的变量：

```cpp
// i是int；p是指针；r是引用
int i = 1024, *p = &i, &r = i;
```

##### 定义多个变量

一个常见的误解：类型修饰符（`*`、 `&`）对语句中所有变量起作用。误解原因之一是，类型修饰符和变量名之间可以有空白符：

```cpp
int* p; // legal but might be misleading
```

即使如此，基础类型仍是 `int`，不是 `int*`。`*` 只作用于 `p`。

```cpp
int* p1, p2; // p1是指针，p2是int
```

因此，最好还是让类型修饰符靠近标识符：

```cpp
int *p1, *p2;
```

##### 指向指针的指针

一般来说，向说明符应用多少个类型修饰符是没有限制的。如 `**` 是指向指针的指针。

```cpp
    int ival = 1024;
    int *pi = &ival;
    int **ppi = &pi;
```

要访问指向的对象，需要解指向两次：

```cpp
    cout << "The value of ival\n"
        << "direct value: " << ival << "\n"
        << "indirect value: " << *pi << "\n"
        << "doubly indirect value: " << **ppi
        << endl;
```

##### 指针的引用

```cpp
int i = 42;
int *p;
int *&r = p; // r是一个引用，指向指针p
r = &i;
*r = 0; // *r即i
```

为理解 `r`，**从右向左读**。**最靠近r的符号决定变量类型**。这里 `r` 是一个引用。