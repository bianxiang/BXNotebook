[toc]

### 17.4 随机数

新标准之前，C和C++都依赖简单的C库函数`rand`。这个函数产生伪随机整数，在0到系统定义的最大值之间均匀分布（uniform distribution）。最大值至少是`32767`。

`rand`函数有几个问题：有的程序需要随机浮点数。有的需要非均匀分布。Programmers often introduce nonrandomness when they try to transform the range, type, or distribution of the numbers generated by `rand`.

随机数库，定义在头`random`，通过几个类协作解决上面的问题：随机数引擎和随机数分布类。引擎产生一个无符号的随机数类。分布器（distribution）利用引擎产生特定类型、范围、分布的随机数。

> 最佳实践：C++逞英雄不应该使用库函数`rand`。应该使用`default_random_engine`配合特定的分布（distribution）对象。

#### 17.4.1. 随机数引擎与分布器（distribution）

随机数引擎是一个函数对象类（§ 14.8），定义了一个调用运算符，没有参数，返回一个随机无符号数。调用引擎对象可以产生一个原始的随机数：

```cpp
	default_random_engine e; // generates random unsigned integers
	for (size_t i = 0; i < 10; ++i)
		// e() "calls" the object to produce the next random number
		cout << e() << " ";
```

在我的系统中，程序产生：`16807 282475249 1622650073 984943658 1144108930 470211272 ...`。

对象`e`的类型是`default_random_engine`。库定义了几种不同的随机数引擎，区别在于性能与随机的质量。编译器选择将其中的某种作为`default_random_engine`。This type is intended to be the engine with the most generally useful properties. 下面写出了引擎类支持的操作。The engine types defined by the standard are listed in § A.3.2.

- `Engine e`：默认构造器，使用默认种子
- `Engine e(s)`：使用一个整数做种子
- `e.seed(s)`：使用种子s重设引擎状态
- `e.min()` `e.max()`：产生的随机数范围
- `Engine::result_type`：引擎产生的无符号整数的类型
- `e.discard(u)`：令引擎向前u步；u的类型是`unsigned long long`

引擎产生的原始值直接用处不大。The problem is that the numbers usually span a range that differs from the one we need. Correctly transforming the range of a random number is surprisingly hard.

##### 分布器（Distribution）类型与引擎

要获取特定范围的值，需要一个分布器对象：

```
    // 均匀分布，从0到9（包括0和9）
    uniform_int_distribution<unsigned> u(0, 9);
    default_random_engine e;
    for (size_t i = 0; i < 10; ++i)
	    cout << u(e) << " ";
```

产生的序列形如：`0 1 7 4 5 2 0 6 6 9`。

与引擎一样，分布器类也是函数对象类。分布器类定义了一个调用运算符，取一个引擎对象做参数。

Note that we pass the engine object itself, `u(e)`. Had we written the call as `u(e())`, we would have tried to pass the next value generated by eto u, which would be a compile-time error. We pass the engine, not the next result of the engine, because some distributions may need to call the engine more than once.

> 当我们提到随机数产生器时，我们指的是引擎和分布器的组合。

##### 随机引擎与`rand`函数的比较

`default_random_engine`对象的输出与`rand`类似。

`rand`产生的的范围是0到`RAND_MAX`。引擎类型返回的范围由`min`和`max`指定：

```cpp
	cout << "min: " << e.min() << " max: " << e.max() << endl;
```

我的系统输出：`min: 1 max: 2147483646`。

##### 引擎产生的序列

一个问题是，一个给定的产生器，每次运行时产生的序列相同。序列不改变的好处是可以方便测试。但有时会有问题。例如，我们需要产生100个随机数，从0到9均匀分布。下面是一种写法：

```cpp
    // 这种写法基本是错误的
    // 每次调用产生的100个数字是相同的
    vector<unsigned> bad_randVec()
    {
        default_random_engine e;
        uniform_int_distribution<unsigned> u(0, 9);
        vector<unsigned> ret;
        for(size_t i = 0; i < 100; ++i)
        	ret.push_back(u(e));
        return ret;
    }
```

每次调用产生的100个数字是相同的：

```cpp
	vector<unsigned> v1(bad_randVec());
	vector<unsigned> v2(bad_randVec());
	// will print equal
	cout << ((v1 == v2) ? "equal" : "not equal") << endl;
```

`v1`和`v2`将相同。正确的写法是让引擎和关联的分布器是静态的：

```cpp
    // returns a vector of 100 uniformly distributed random numbers
    vector<unsigned> good_randVec()
    {
        static default_random_engine e;
        static uniform_int_distribution<unsigned> u(0, 9);
        vector<unsigned> ret;
        for(size_t i = 0; i < 100; ++i)
        	ret.push_back(u(e));
        return ret;
    }
```

Because e and u are static, they will hold their state across calls to the function.

> 警告：A given random-number generator always produces the same sequence of numbers. A function with a local random-number generator should make that generator (both the engine and distribution objects) `static`. Otherwise, the function will generate the identical sequence on each call.

##### 种子

The fact that a generator returns the same sequence of numbers is helpful during debugging. 但程序测试后，我们期望程序每次运行产生不同的随机值。通过种子实现。A seed is a value that an engine can use to cause it to start generating numbers at a new point in its sequence.

种子可以在创建时指定，或通过`seed`方法指定：

```cpp
	default_random_engine e1; // 使用默认种子
	default_random_engine e2(2147483646); // 使用指定种子
    // e3和e4的种子相同，因此它们产生的序列相同
    default_random_engine e3;
    e3.seed(32767);
    default_random_engine e4(32767); // set the seed value to 32767
    for (size_t i = 0; i != 100; ++i) {
        if (e1() == e2())
        	cout << "unseeded match at iteration: " << i << endl;
        if(e3() != e4())
	        cout << "seeded differs at iteration: " << i << endl;
    }
```

选择一个好的种子是很难的。或许最常见的方法是调用系统的`time`函数。该函数在`ctime`头中。返回秒数。The `time` function takes a single parameter that is a pointer to a structure into which to write the time. 如果指针为null，则只是返回时间：

```
	default_random_engine e1(time(0));
```

因为`time`返回的时间是秒级，因此这个种子只适合产生秒级的种子。

> 警告：Using `time` as a seed usually doesn’t work if the program is run repeatedly as part of an automated process; it might wind up with the same seed several times.

#### （未）17.4.2. 其他分布


